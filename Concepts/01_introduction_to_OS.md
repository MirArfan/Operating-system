## ЁЯза Introduction to Operating System (OS)

 
An **Operating System (OS)** is a system software that acts as an interface between the user and the computer hardware.  
It manages the hardware resources, runs applications, and provides an environment where users can execute programs easily and efficiently.  
>In simple words, itтАЩs the **bridge between the user and the machine**.  

**Examples:** Windows, Linux, macOS, Android, iOS.


**Operating System (OS)** рж╣рж▓рзЛ ржПржоржи ржПржХ ржзрж░ржирзЗрж░ **system software**, ржпрж╛ **user** ржПржмржВ **computer hardware**-ржПрж░ ржоржзрзНржпрзЗ ржоржзрзНржпрж╕рзНржерждрж╛ (interface) ржХрж░рзЗред  
ржПржЯрж┐ ржХржорзНржкрж┐ржЙржЯрж╛рж░рзЗрж░ рж╣рж╛рж░рзНржбржУржпрж╝рзНржпрж╛рж░ рж░рж┐рж╕рзЛрж░рзНрж╕ ржкрж░рж┐ржЪрж╛рж▓ржирж╛ ржХрж░рзЗ, ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржЪрж╛рж▓рж╛рзЯ, ржПржмржВ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржЬржирзНржп ржПржХржЯрж┐ рж╕рж╣ржЬ ржУ ржХрж╛рж░рзНржпржХрж░ ржкрж░рж┐ржмрзЗрж╢ рждрзИрж░рж┐ ржХрж░рзЗред  

<br>

### тЪЩя╕П Main Functions of Operating System  

| ЁЯзй Function | ЁЯз╛ Description (English) |  ржмрж╛ржВрж▓рж╛ ржЕрж░рзНрже |
|-------------|---------------------------|----------------|
| **Process Management** | Manages running programs and allocates CPU time. | ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржЪрж╛рж▓рж╛ржирзЛ ржУ CPU-рж░ рж╕ржорзЯ ржмржгрзНржЯржи ржирж┐рзЯржирзНрждрзНрж░ржг ржХрж░рзЗред |
| **Memory Management** | Keeps track of memory usage and allocates memory to processes. | ржорзЗржорж░рж┐ ржХрзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржЫрзЗ рждрж╛ ржЯрзНрж░рзНржпрж╛ржХ ржХрж░рзЗ ржПржмржВ ржкрзНрж░рзЯрзЛржЬржиржорждрзЛ ржнрж╛ржЧ ржХрж░рзЗ ржжрзЗрзЯред |
| **File Management** | Handles creation, deletion, and access of files. | ржлрж╛ржЗрж▓ рждрзИрж░рж┐, ржорзБржЫрзЗ ржлрзЗрж▓рж╛ ржУ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржХрж░рж╛ ржирж┐рзЯржирзНрждрзНрж░ржг ржХрж░рзЗред |
| **I/O Management** | Controls input/output devices like keyboard, mouse, printer, etc. | ржЗржиржкрзБржЯ ржУ ржЖржЙржЯржкрзБржЯ ржбрж┐ржнрж╛ржЗрж╕ржЧрзБрж▓рзЛрж░ ржХрж╛рж░рзНржпржХрзНрж░ржо ржкрж░рж┐ржЪрж╛рж▓ржирж╛ ржХрж░рзЗред |
| **Security & Protection** | Prevents unauthorized access and ensures data safety. | ржЕржиржирзБржорзЛржжрж┐ржд ржкрзНрж░ржмрзЗрж╢ рж░рзЛржз ржХрж░рзЗ ржПржмржВ ржбрзЗржЯрж╛рж░ ржирж┐рж░рж╛ржкрждрзНрждрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзЗред |
| **Error Handling** | Detects and recovers from system errors. | рж╕рж┐рж╕рзНржЯрзЗржорзЗ ржХрзЛржирзЛ рждрзНрж░рзБржЯрж┐ рж╣рж▓рзЗ рждрж╛ рж╢ржирж╛ржХрзНржд ржХрж░рзЗ ржПржмржВ рж╕ржорж╛ржзрж╛ржи ржжрзЗрзЯред |



### ЁЯОп Why Do We Need an Operating System?

Without an OS, users would have to manually control every hardware operation тАФ  
like memory management, input/output, and file operations тАФ which is **complex and time-consuming**.  
The **Operating System** simplifies this by managing everything automatically.

**In short:**  
>  **OS = Resource Manager + User Interface + Control System**



### тЬЕ What is a Program?
A program is a set of instructions written in a programming language that defines a specific task or functionality

It is a passive entity, meaning itтАЩs just code stored in memory (it doesnтАЩt perform any task until executed).

ржПржЯрж┐ ржирж┐рж╖рзНржХрзНрж░рж┐рзЯ (passive) ржЕржмрж╕рзНржерж╛рзЯ ржерж╛ржХрзЗ тАФ ржЕрж░рзНржерж╛рзО рж╢рзБржзрзБ ржорзЗржорж░рж┐рждрзЗ ржХрзЛржб рж╣рж┐рж╕рзЗржмрзЗ рж╕ржВрж░ржХрзНрж╖рж┐ржд ржерж╛ржХрзЗ, ржХрж╛ржЬ рж╢рзБрж░рзБ ржХрж░рзЗ ржирж╛ ржпрждржХрзНрж╖ржг ржирж╛ ржПржХрзНрж╕рж┐ржХрж┐ржЙржЯ ржХрж░рж╛ рж╣рзЯред

**Example**: A C++ file like main.cpp or a Python file like app.py


### тЬЕ What is Process
A **process** is a program in execution. It is an active entity that uses CPU and memory to perform a task.  
Each process has its own **memory space**, **program counter**, and **resources**.  


**Process** рж╣рж▓рзЛ ржПржХржЯрж┐ **ржЪрж▓ржорж╛ржи ржкрзНрж░рзЛржЧрзНрж░рж╛ржо** тАФ ржЕрж░рзНржерж╛рзО ржпржЦржи ржХрзЛржирзЛ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо CPU рждрзЗ ржЪрж▓рждрзЗ ржерж╛ржХрзЗ, рждржЦржи рж╕рзЗржЯрж┐ржЗ process ржирж╛ржорзЗ ржкрж░рж┐ржЪрж┐рждред  


> Each process runs independently.

**Example**: Opening two Chrome windows = two processes of Chrome.

### тЬЕ What is Thread

A **thread**, on the other hand, is the smallest unit of a process that can be scheduled and executed.  
Multiple threads within the same process share the same memory and resources, but execute independently.

**Thread** рж╣рж▓рзЛ process-ржПрж░ рж╕ржмржЪрзЗрзЯрзЗ ржЫрзЛржЯ ржХрж╛ржЬрзЗрж░ ржПржХржХред  
ржПржХржЯрж┐ process-ржПрж░ ржоржзрзНржпрзЗ ржПржХрж╛ржзрж┐ржХ thread ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗ, ржПржмржВ рждрж╛рж░рж╛ ржПржХржЗ ржорзЗржорж░рж┐ ржнрж╛ржЧ ржХрж░рзЗ ржирзЗрзЯ ржХрж┐ржирзНрждрзБ рж╕рзНржмрж╛ржзрзАржиржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗред


**Example**: A web browser тАФ one thread loads the page, another downloads files, another renders UI.

<br>

### ЁЯФД Program vs Process vs Thread

| Term | Description (English) | ржмрж╛ржВрж▓рж╛ ржЕрж░рзНрже |
|------|------------------------|-------------|
| **Program** | A passive collection of instructions stored on disk. | ржбрж┐рж╕рзНржХрзЗ рж╕ржВрж░ржХрзНрж╖рж┐ржд ржирж┐рж░рзНржжрзЗрж╢ржирж╛рж░ ржПржХржЯрж┐ рж╕рзНржерж┐рж░ рж╕рзЗржЯред |
| **Process** | A program in execution (active state). | ржЪрж▓ржорж╛ржи ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржпрж╛ CPU ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржХрж╛ржЬ ржХрж░рзЗред |
| **Thread** | The smallest unit of execution within a process. | Process-ржПрж░ ржнрж┐рждрж░рзЗ ржХрж╛ржЬрзЗрж░ рж╕ржмржЪрзЗрзЯрзЗ ржЫрзЛржЯ ржЗржЙржирж┐ржЯред |



### ЁЯза Example 
```c++
#include <iostream>
#include <thread>   // for std::thread

using namespace std;

// Function that will run as a thread
void task() {
    cout << "Thread is running!" << endl;
}

int main() {
    // Create a thread and run the 'task' function
    thread t1(task);

    // Wait for the thread to finish
    t1.join();

    cout << "Main process completed." << endl;

    return 0;
}

```

### Output:
```
Thread is running!
Main process completed.
```


### ЁЯзй Explanation

- std::thread рж╣рж▓ C++11 ржП introduce ржХрж░рж╛ class, ржпрж╛ ржжрж┐рзЯрзЗ thread рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯред
- thread t1(task); тЖТ task() ржлрж╛ржВрж╢ржиржЯрж┐ ржирждрзБржи ржерзНрж░рзЗржбрзЗ рж░рж╛ржи рж╣ржмрзЗред
- t1.join(); тЖТ main thread ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржмрзЗ ржпрждржХрзНрж╖ржг ржирж╛ t1 рж╢рзЗрж╖ рж╣рзЯред
- рж╢рзЗрж╖рзЗ "Main process completed." ржкрзНрж░рж┐ржирзНржЯ рж╣ржмрзЗред


### ЁЯзй Process States

A process goes through different states during its lifetime:

| State | Description |
|------|--------------|
| **New** | OProcess is being created. |
| **Ready** | Waiting to be assigned to CPU. |
| **Running** | Currently using CPU.|
| **Waiting/Blocked** | Waiting for I/O or event.|
| **Terminated** |Process has finished execution. |




### ЁЯзн Process State Diagram
```
        +-------+
        |  New  |
        +---+---+
            |
            v
        +---+---+
        | Ready |
        +---+---+
            |
            v
        +---+---+
        |Running|
        +---+---+
         ^   |
         |   v
   +-----+   +------+
   |Waiting|        |
   +------+         |
         \__________/
             тЖУ
        +----------+
        |Terminated|
        +----------+

```

### ЁЯзй Process vs Thread (Comparison Table)


Process ржПржмржВ Thread ржХржорзНржкрж┐ржЙржЯрж╛рж░ рж╕рж┐рж╕рзНржЯрзЗржорзЗ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг ржзрж╛рж░ржгрж╛ред ржирж┐ржЪрзЗрж░ table ржП рждрж╛ржжрзЗрж░ ржкрзНрж░ржзрж╛ржи ржкрж╛рж░рзНржержХрзНржп ржжрзЗржЦрж╛ржирзЛ рж╣рж▓рзЛ:

| Feature        | Process                                                    | Thread                                                   |
|----------------|------------------------------------------------------------|----------------------------------------------------------|
| **Definition** | A program in execution with its own memory and resources. | The smallest unit of a process that can run independently. |
| **Dependency** | Independent of other processes.                            | Depends on the parent process.                           |
| **Memory Usage** | Has separate memory space (high memory use).            | Shares memory with other threads (low memory use).       |
| **Communication** | Requires Inter-Process Communication (IPC).            | Communicates easily through shared memory.              |
| **Creation Time** | Takes more time to create.                               | Faster to create.                                        |
| **Crash Impact** | If one process crashes, it doesnтАЩt affect others.       | If one thread crashes, it may affect the whole process. |
| **CPU Switching** | More overhead (context switching is costly).            | Less overhead (context switching is faster).            |
| **Example**    | Running two Chrome windows.                                | Two Chrome tabs loading pages simultaneously.           |

<br>

### ЁЯзй рж╕рж╣ржЬржнрж╛ржмрзЗ ржмрзЛржЭрж╛рж░ ржЬржирзНржп

- **Process**: рж╕ржорзНржкрзВрж░рзНржг ржПржХржЯрж┐ app instance  
  - ржЙржжрж╛рж╣рж░ржг: Chrome ржПрж░ ржжрзБржЯрж┐ ржЖрж▓рж╛ржжрж╛ window ржЦрзЛрж▓рж╛ред  
- **Thread**: рж╕рзЗржЗ app ржПрж░ sub-task  
  - ржЙржжрж╛рж╣рж░ржг: Chrome ржПрж░ ржкрзНрж░рждрж┐ржЯрж╛ tab ржЖрж▓рж╛ржжрж╛ thread ржП ржЪрж▓рзЗред  




### ЁЯФ╣ Multithreading

**Multithreading** is the ability of a CPU or a single process to **execute multiple threads simultaneously**.

 It helps in performing multiple tasks at the same time, improving performance and responsiveness.

**Example**: In a browser тАФ one thread handles UI, another plays video, another downloads files тАФ all together.

**Multithreading** рж╣рж▓рзЛ ржПржоржи ржПржХржЯрж┐ ржХрзМрж╢рж▓ ржпрзЗржЦрж╛ржирзЗ ржПржХржЯрж┐ process-ржПрж░ ржнрзЗрждрж░рзЗ ржПржХрж╛ржзрж┐ржХ thread ржПржХрж╕рж╛ржерзЗ ржХрж╛ржЬ ржХрж░рзЗред
 ржПрждрзЗ performance ржУ responsiveness ржмрзГржжрзНржзрж┐ ржкрж╛рзЯ ржХрж╛рж░ржг ржПржХржЗ рж╕ржорзЯрзЗ ржПржХрж╛ржзрж┐ржХ ржХрж╛ржЬ рж╕ржорзНржкржирзНржи рж╣рзЯред



### ЁЯФ╣ Advantages of Multithreading

Multithreading allows multiple threads to run concurrently within a single process. Below are the main advantages:

| Advantage                | Description                                                                 |
|--------------------------|-----------------------------------------------------------------------------|
| **Faster Execution**      | Multiple tasks run simultaneously, reducing total execution time.          |
| **Better Resource Utilization** | Threads share memory & resources efficiently.                           |
| **Responsiveness**        | Application remains responsive even if one thread is blocked.              |
| **Lower Overhead**        | Thread creation & context switching is lighter than process creation.      |


<br>

### ЁЯФ╣ Example in C++ (Multithreading)
```c++
#include <iostream>
#include <thread>

using namespace std;

void task1() {
    cout << "Thread 1 is running!" << endl;
}

void task2() {
    cout << "Thread 2 is running!" << endl;
}

int main() {
    thread t1(task1);
    thread t2(task2);

    // Wait for threads to finish
    t1.join();
    t2.join();

    cout << "Main process completed." << endl;
    return 0;
}

```
Output:
```
Thread 1 is running!
Thread 2 is running!
Main process completed.
```

### ЁЯФ╣ Key Points

- **Single Process, Multiple Threads**: ржПржХ process-ржПрж░ ржоржзрзНржпрзЗ ржЕржирзЗржХ thread ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред

- **Shared Memory**: Threads ржПржХржЗ memory share ржХрж░рзЗред

- **Independent Execution**: ржкрзНрж░рждрж┐ржЯрж┐ thread ржЖрж▓рж╛ржжрж╛ржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░рзЗред

- **Use Cases**: Web servers, GUI applications, real-time simulations, parallel computationред

<br>

### ЁЯФ╣ Q&A

### ЁЯФ╣What is multithreading?
> Running multiple threads of a process concurrently.

### ЁЯФ╣Difference between multithreading and multiprocessing?
> Multithreading = multiple threads in same process, shared memory.
> Multiprocessing = multiple processes, separate memory.

### ЁЯФ╣Advantages of multithreading?
> Faster execution, better resource utilization, responsive programs, lower overhead.



<br>

## ЁЯза Types of Operating System (OS)


### 1. ЁЯЧВя╕П Batch Operating System

#### ЁЯСЙ Definition 
In a **Batch Operating System**, similar jobs are collected together and executed in batches, without user interaction during execution.

#### ЁЯУЭ 
**Batch Operating System** ржП ржПржХржЗ ржзрж░ржирзЗрж░ ржХрж╛ржЬржЧрзБрж▓рзЛ (jobs) ржПржХрждрзНрж░ ржХрж░рзЗ **batch ржЖржХрж╛рж░рзЗ execute** ржХрж░рж╛ рж╣рзЯред  
ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА рж╕рж░рж╛рж╕рж░рж┐ ржХржорзНржкрж┐ржЙржЯрж╛рж░рзЗрж░ рж╕рж╛ржерзЗ ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзЗ ржирж╛ тАФ рж╕ржм ржХрж╛ржЬ ржПржХрж╕рж╛ржерзЗ queue рждрзЗ ржЬржорж╛ рж╣рзЯ, рждрж╛рж░ржкрж░ ржПржХрзЗрж░ ржкрж░ ржПржХ ржЪрж▓рзЗред

#### тЪЩя╕П Working Principle
- User submits jobs to an operator.  
- Operator groups similar jobs.  
- OS executes them sequentially (one batch after another).

#### тЬЕ Advantages
- CPU utilization is high.  
- Ideal for long and repetitive jobs.

#### тЭМ Disadvantages
- No user interaction during execution.  
- Debugging errors is difficult.

#### ЁЯУШ Examples
Payroll system, Bank cheque processing, Billing systems.

---

### 2. ЁЯТ╗ Multiprogramming Operating System

#### ЁЯСЙ Definition (English)
A **Multiprogramming OS** allows multiple programs to reside in main memory at the same time, and the CPU switches between them to keep itself busy.

#### ЁЯУЭ 
**Multiprogramming OS** ржП ржПржХрж╛ржзрж┐ржХ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржПржХрж╕рж╛ржерзЗ **main memory** рждрзЗ рж▓рзЛржб ржерж╛ржХрзЗред  
CPU ржХрзЛржирзЛ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо **I/O ржПрж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рж▓рзЗ**, ржЕржирзНржп ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржЪрж╛рж▓рж╛рзЯ тАФ ржлрж▓рзЗ CPU ржХржЦржирзЛ idle ржерж╛ржХрзЗ ржирж╛ред

#### тЪЩя╕П Working Principle
- Multiple programs are kept in memory.  
- When one waits for I/O, CPU executes another.  
- Increases CPU utilization.

#### тЬЕ Advantages
- Efficient use of CPU.  
- Faster execution compared to Batch OS.

#### тЭМ Disadvantages
- Complex memory management.  
- Difficult to handle errors.

#### ЁЯУШ Examples
IBM OS/360, UNIX (early versions).

---

### 3. тП▒я╕П Real-Time Operating System (RTOS)

#### ЁЯСЙ Definition 
A **Real-Time OS** processes data immediately and responds within a specific time limit.

#### ЁЯУЭ 
**Real-Time OS** ржПржоржи ржПржХржЯрж┐ Operating System ржпрж╛ ржХрзЛржирзЛ event ржШржЯрж╛рж░ рж╕рж╛ржерзЗ рж╕рж╛ржерзЗржЗ **fixed time limit** ржПрж░ ржоржзрзНржпрзЗ response ржжрзЗрзЯред  
ржПржЯрж╛ рж╕рж╛ржзрж╛рж░ржгржд **critical systems** ржП ржмрзНржпржмрж╣рж╛рж░ рж╣рзЯ (ржпрзЗржоржи flight control, medical system)ред

#### тЪЩя╕П Types
- **Hard Real-Time OS:** Strict time constraint (e.g., Flight control).  
- **Soft Real-Time OS:** Slight delay acceptable (e.g., Multimedia system).

#### тЬЕ Advantages
- Predictable and consistent response.  
- High reliability.

#### тЭМ Disadvantages
- Complex system design.  
- Limited multitasking ability.

#### ЁЯУШ Examples
RTLinux, QNX, VxWorks.

---

### 4. ЁЯМР Distributed Operating System

#### ЁЯСЙ Definition 
A **Distributed OS** manages a group of independent computers (nodes) connected via a network and makes them appear as a single system to users.

#### ЁЯУЭ 
**Distributed OS** ржЕржирзЗржХржЧрзБрж▓рзЛ ржХржорзНржкрж┐ржЙржЯрж╛рж░ржХрзЗ (nodes) network ржПрж░ ржорж╛ржзрзНржпржорзЗ рж╕ржВржпрзБржХрзНржд ржХрж░рзЗ ржПржоржиржнрж╛ржмрзЗ resource share ржХрж░рзЗ  
ржпрзЗржи ржкрзБрж░рзЛ рж╕рж┐рж╕рзНржЯрзЗржоржЯрж┐ржХрзЗ **ржПржХржЯрж╛ржЗ ржмрзЬ ржХржорзНржкрж┐ржЙржЯрж╛рж░** ржоржирзЗ рж╣рзЯред

#### тЪЩя╕П Working Principle
- Each node runs part of the OS.  
- Communication via message passing.  
- Provides shared access to files, printers, etc.

#### тЬЕ Advantages
- Load balancing.  
- Fault tolerance (one node fails, others work).

#### тЭМ Disadvantages
- Complex design & maintenance.  
- Security management is harder.

#### ЁЯУШ Examples
Amoeba, LOCUS, Chorus, Inferno.

---

### 5. ЁЯФМ Embedded Operating System

#### ЁЯСЙ Definition 
An **Embedded OS** is designed to operate on small devices with limited hardware resources, often dedicated to specific functions.

#### ЁЯУЭ 
**Embedded OS** ржЫрзЛржЯ ржПржмржВ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржХрж╛ржЬрзЗрж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд ржбрж┐ржнрж╛ржЗрж╕рзЗрж░ ржЬржирзНржп рждрзИрж░рж┐ рж╣рзЯ, ржпрзЗржоржи тАФ  
washing machine, ATM, smart watch, router ржЗрждрзНржпрж╛ржжрж┐ред

#### тЪЩя╕П Characteristics
- Lightweight and fast.  
- Works with limited memory and CPU.  
- Real-time performance.

#### тЬЕ Advantages
- Reliable and efficient.  
- Uses minimal resources.

#### тЭМ Disadvantages
- Hard to upgrade or modify.  
- Limited user interface.

#### ЁЯУШ Examples
Windows CE, Embedded Linux, VxWorks, Android Things.

---

### ЁЯз╛ Summary Table

| Type of OS | Key Feature | Example |
|-------------|-------------|----------|
| Batch OS | Executes jobs in batches | Payroll System |
| Multiprogramming OS | Multiple programs in memory | IBM OS/360 |
| Real-Time OS | Immediate response | RTLinux |
| Distributed OS | Connected systems act as one | Amoeba |
| Embedded OS | Runs on small devices | Android Things |

---




# ЁЯЧВя╕П Batch Operating System (ржмрзНржпрж╛ржЪ ржЕржкрж╛рж░рзЗржЯрж┐ржВ рж╕рж┐рж╕рзНржЯрзЗржо)

## ЁЯзй Definition (рж╕ржВржЬрзНржЮрж╛)

**English:**  
A **Batch Operating System** is one of the earliest types of OS, where similar jobs are grouped together into batches and executed one after another without any user interaction during execution.

**ржмрж╛ржВрж▓рж╛рзЯ:**  
Batch Operating System рж╣рж▓рзЛ ржкрзНрж░рж╛ржЪрзАржирждржо OS ржЧрзБрж▓рзЛрж░ ржПржХржЯрж┐,  
ржпрзЗржЦрж╛ржирзЗ ржПржХржЗ ржзрж░ржирзЗрж░ ржХрж╛ржЬ (jobs) ржПржХрждрзНрж░ ржХрж░рзЗ batch ржЖржХрж╛рж░рзЗ ржПржХрж╕рж╛ржерзЗ ржЪрж╛рж▓рж╛ржирзЛ рж╣рзЯред  
ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржЪрж▓рж╛рж░ рж╕ржорзЯ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ рж╕рж░рж╛рж╕рж░рж┐ ржХрзЛржирзЛ ржЗржиржкрзБржЯ ржмрж╛ ржЗржирзНржЯрж╛рж░ржЕрзНржпрж╛ржХрж╢ржи ржерж╛ржХрзЗ ржирж╛ред

---

## тЪЩя╕П How It Works (ржХрж╛ржЬ ржХрж░рж╛рж░ ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛)

**English (Steps):**
1. Users prepare their jobs (programs + data) and submit them to an operator.  
2. The operator collects similar types of jobs and forms a batch.  
3. The batch is then loaded into the system and executed sequentially (one after another).  
4. Once one job finishes, the next one in the batch begins.

**ржмрж╛ржВрж▓рж╛рзЯ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ:**
1. ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА рждрж╛ржжрзЗрж░ ржХрж╛ржЬ (program + data) рждрзИрж░рж┐ ржХрж░рзЗ ржЕржкрж╛рж░рзЗржЯрж░ржХрзЗ ржжрзЗрзЯред  
2. ржЕржкрж╛рж░рзЗржЯрж░ ржПржХржЗ ржзрж░ржирзЗрж░ ржХрж╛ржЬржЧрзБрж▓рзЛ ржПржХрждрзНрж░ ржХрж░рзЗ ржПржХржЯрж┐ batch ржмрж╛ржирж╛рзЯред  
3. ржмрзНржпрж╛ржЪржЯрж┐ рж╕рж┐рж╕рзНржЯрзЗржорзЗ рж▓рзЛржб рж╣рзЯ ржПржмржВ ржПржХржЯрж┐рж░ ржкрж░ ржПржХржЯрж┐ ржХрж╛ржЬ ржЪрж▓рзЗред  
4. ржПржХржЯрж┐ ржХрж╛ржЬ рж╢рзЗрж╖ рж╣рж▓рзЗ ржкрж░рзЗрж░ ржХрж╛ржЬржЯрж┐ рж╢рзБрж░рзБ рж╣рзЯред

---

## ЁЯзо Example Scenario

| Job  | Task                | Arrival | Execution Order |
|------|---------------------|----------|-----------------|
| Job1 | Payroll calculation | 0        | 1st             |
| Job2 | Salary report       | 1        | 2nd             |
| Job3 | Tax calculation     | 2        | 3rd             |

ЁЯза All jobs are executed **one after another**, without waiting for user input.

---

## ЁЯУИ Performance Metric (ржжржХрзНрж╖рждрж╛рж░ ржкрж░рж┐ржорж╛ржк)

Batch systems are measured by **Throughput**,  
тЮбя╕П i.e., how many jobs are completed in a given period of time.  

**ржмрж╛ржВрж▓рж╛рзЯ:**  
ржирж┐рж░рзНржжрж┐рж╖рзНржЯ рж╕ржорзЯрзЗрж░ ржоржзрзНржпрзЗ ржХрждржЧрзБрж▓рзЛ ржХрж╛ржЬ рж╢рзЗрж╖ рж╣ржЪрзНржЫрзЗ тАФ ржПржЯрж┐ржЗ **ржерзНрж░рзБржкрзБржЯ (Throughput)**ред

---

## тЬЕ Advantages (рж╕рзБржмрж┐ржзрж╛)

- ЁЯзо **High throughput:** ржЕржирзЗржХ ржХрж╛ржЬ ржПржХрж╕рж╛ржерзЗ ржХрж░рж╛ ржпрж╛рзЯред  
- тЪЩя╕П **Automatic execution:** ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржЙржкрж╕рзНржерж┐рждрж┐ ржЫрж╛рзЬрж╛ржЗ ржХрж╛ржЬ ржЪрж▓рзЗред  
- ЁЯФБ **Good for repetitive jobs:** ржпрзЗржоржи payroll, billing, data processingред  
- ЁЯза **Efficient resource utilization:** CPU idle ржерж╛ржХрзЗ ржирж╛ред

---

## тЭМ Disadvantages (ржЕрж╕рзБржмрж┐ржзрж╛)

- ЁЯЪл **No real-time interaction:** ржХрж╛ржЬ рж╢рзБрж░рзБ рж╣рж▓рзЗ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж╛ ржпрж╛рзЯ ржирж╛ред  
- ЁЯк▓ **Debugging is difficult:** Error ржзрж░рж╛ ржХржарж┐ржи ржХрж╛рж░ржг ржХрж╛ржЬ ржПржХрж╕рж╛ржерзЗ ржЪрж▓рзЗред  
- ЁЯХУ **High turnaround time:** рж╕ржм ржХрж╛ржЬ рж╢рзЗрж╖ ржирж╛ рж╣ржУрзЯрж╛ ржкрж░рзНржпржирзНржд output ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯ ржирж╛ред  
- тЪЦя╕П **No priority:** ржЖржЧрзЗ ржжрзЗржУрзЯрж╛ ржХрж╛ржЬ ржЖржЧрзЗ ржЪрж▓рзЗ, рж╕ржорзЯ ржЕржирзБржпрж╛рзЯрзА ржирзЯред

---

### ЁЯз░ Use Cases (ржмрзНржпржмрж╣рж╛рж░ ржХрзНрж╖рзЗрждрзНрж░)

| Use Case | Example |
|-----------|----------|
| Payroll Processing | Employee salary calculation |
| Data Processing | Banking data, statistics |
| Report Generation | Monthly or yearly reports |

---

### ЁЯЦея╕П Examples of Batch Operating Systems

- IBMтАЩs Mainframe OS (e.g., **IBM z/OS**)  
- **Early UNIX systems**  
- **Microsoft DOS** (when used in batch scripts)

---

### ЁЯТм In Interview (How to Explain)

**English:**  
ЁЯЧгя╕П "A Batch Operating System is one of the earliest OS types where similar jobs are grouped into batches and executed sequentially without user interaction. ItтАЩs mainly used for large data processing tasks like payroll, billing, or reports. Its main advantage is high throughput, but it lacks interactivity and has high turnaround time."

**ржмрж╛ржВрж▓рж╛рзЯ:**  
тАЬBatch Operating System рж╣рж▓рзЛ ржПржоржи ржПржХржЯрж┐ рж╕рж┐рж╕рзНржЯрзЗржо ржпрзЗржЦрж╛ржирзЗ ржПржХржЗ ржзрж░ржирзЗрж░ ржХрж╛ржЬржЧрзБрж▓рзЛ ржПржХрждрзНрж░ ржХрж░рзЗ ржПржХрж╕рж╛ржерзЗ ржЪрж╛рж▓рж╛ржирзЛ рж╣рзЯ, ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ рж╕рж░рж╛рж╕рж░рж┐ ржХрзЛржирзЛ ржнрзВржорж┐ржХрж╛ ржерж╛ржХрзЗ ржирж╛ред ржПржЯрж╛ рж╕рж╛ржзрж╛рж░ржгржд ржмрзЬ ржбрзЗржЯрж╛ ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛ржХрж░ржгрзЗрж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рж╣рзЯ, ржпрзЗржоржи ржкрзЗрж░рзЛрж▓ ржмрж╛ рж░рж┐ржкрзЛрж░рзНржЯ рждрзИрж░рж┐редтАЭ

---

# ЁЯЦея╕П Multiprogramming & Multitasking Operating Systems

---

## тЪЩя╕П Multiprogramming Operating System

### ЁЯФ╕ English Explanation:
A **Multiprogramming Operating System** allows multiple programs to be loaded into memory at the same time.  
However, only **one program uses the CPU at a time** тАФ when one program is waiting for I/O operations (like reading from disk), the CPU switches to another program.

тЬЕ **Goal:** To increase CPU utilization and reduce idle time.

ЁЯзй **Example:** UNIX, Linux, Windows NT, etc.

---

### ЁЯФ╣ Bangla Explanation:
**Multiprogramming OS** ржПржоржи ржПржХржЯрж┐ рж╕рж┐рж╕рзНржЯрзЗржо ржпрзЗржЦрж╛ржирзЗ ржПржХрж╛ржзрж┐ржХ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржорзЗржорж░рж┐рждрзЗ ржПржХрж╕рж╛ржерзЗ рж░рж╛ржЦрж╛ ржпрж╛рзЯред  
рждржмрзЗ ржПржХржЗ рж╕ржорзЯрзЗ CPU ржХрзЗржмрж▓ржорж╛рждрзНрж░ ржПржХржЯрж┐ ржкрзНрж░рзЛржЧрзНрж░рж╛ржоржХрзЗ ржПржХрзНрж╕рж┐ржХрж┐ржЙржЯ ржХрж░рзЗред  
ржпржЦржи ржПржХржЯрж┐ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо **I/O ржПрж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ**, CPU рждржЦржи ржЕржирзНржп ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржЪрж╛рж▓рзБ ржХрж░рзЗред

ЁЯОп **рж▓ржХрзНрж╖рзНржп:** CPU ржпрзЗржи ржлрж╛ржБржХрж╛ ржирж╛ ржерж╛ржХрзЗ, ржЕрж░рзНржерж╛рзО **CPU utilization ржмрж╛рзЬрж╛ржирзЛред**

ЁЯУШ **ржЙржжрж╛рж╣рж░ржг:** UNIX, Linux, Windows NT

---

## тЪЩя╕П Multitasking Operating System

### ЁЯФ╕ English Explanation:
A **Multitasking Operating System** allows multiple tasks (or processes) to be executed apparently at the same time by **switching rapidly** between them.  
Each task gets a small **time slice** of CPU тАФ this switching happens so fast that the user feels all tasks are running simultaneously.

тЬЕ **Goal:** To improve user responsiveness and make efficient use of CPU time.

ЁЯзй **Example:** Windows, macOS, Linux

---

### ЁЯФ╣ Bangla Explanation:
**Multitasking OS** ржПржоржи ржПржХржЯрж┐ рж╕рж┐рж╕рзНржЯрзЗржо ржпрзЗржЦрж╛ржирзЗ ржПржХрж╛ржзрж┐ржХ ржХрж╛ржЬ ржПржХржЗ рж╕ржорзЯрзЗ ржЪрж▓рждрзЗ ржерж╛ржХрзЗ ржоржирзЗ рж╣рзЯ,  
ржХрж╛рж░ржг CPU ржЦрзБржм ржжрзНрж░рзБржд ржПржХ ржХрж╛ржЬ ржерзЗржХрзЗ ржЕржирзНржп ржХрж╛ржЬрзЗ **switch** ржХрж░рзЗред  
ржкрзНрж░рждрж┐ржЯрж┐ ржХрж╛ржЬрзЗрж░ ржЬржирзНржп CPU ржерзЗржХрзЗ ржПржХржЯрж┐ ржЫрзЛржЯ **time slice** ржмрж░рж╛ржжрзНржж ржХрж░рж╛ рж╣рзЯред

ЁЯОп **рж▓ржХрзНрж╖рзНржп:** ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржЬржирзНржп ржжрзНрж░рзБржд ржкрзНрж░рждрж┐ржХрзНрж░рж┐рзЯрж╛ (response) ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рж╛ ржПржмржВ CPU рж╕ржорзЯрзЗрж░ рж╕ржарж┐ржХ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ред

ЁЯУШ **ржЙржжрж╛рж╣рж░ржг:** Windows, macOS, Linux

---

## тЪЦя╕П Difference Between Multiprogramming and Multitasking

| **Feature** | **Multiprogramming** | **Multitasking** |
|--------------|----------------------|------------------|
| **Definition** | Multiple programs in memory, CPU executes one at a time | Multiple tasks executed apparently simultaneously |
| **CPU Sharing** | CPU switches when one job waits for I/O | CPU switches rapidly between active tasks |
| **Objective** | Increase CPU utilization | Improve user responsiveness |
| **User Interaction** | No direct user interaction | User interacts directly |
| **Examples** | UNIX, Windows NT | Windows, macOS, Linux |

---

ЁЯТм **In Short:**  
тЮбя╕П Multiprogramming focuses on **CPU utilization**,  
тЮбя╕П Multitasking focuses on **user responsiveness**.

---
# тЪЩя╕П Benefits, Challenges & Use Cases of Multiprogramming and Multitasking Operating Systems

---

## ЁЯЯв Benefits (рж╕рзБржмрж┐ржзрж╛рж╕ржорзВрж╣)

### ЁЯТа Higher CPU Utilisation (ржЙржЪрзНржЪ CPU ржмрзНржпржмрж╣рж╛рж░рзЗрж░ рж╣рж╛рж░)
Multiprogramming ржмрж╛ Multitasking OS CPU-ржХрзЗ ржПржХрж╛ржзрж┐ржХ ржХрж╛ржЬрзЗрж░ ржоржзрзНржпрзЗ ржжрзНрж░рзБржд switch ржХрж░рждрзЗ ржжрзЗрзЯред  
ржПрж░ ржлрж▓рзЗ CPU ржХржЦржирзЛ ржлрж╛ржБржХрж╛ ржерж╛ржХрзЗ ржирж╛, **idle time ржХржорзЗ ржпрж╛рзЯ** ржПржмржВ **throughput ржмрж╛рзЬрзЗ**ред

---

### тЪб Improved Responsiveness (ржжрзНрж░рзБржд ржкрзНрж░рждрж┐ржХрзНрж░рж┐рзЯрж╛)
ржПржХрж╛ржзрж┐ржХ ржХрж╛ржЬ ржПржХрж╕рж╛ржерзЗ ржЪрж▓рж╛рж░ ржХрж╛рж░ржгрзЗ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржЬржирзНржп рж╕рж┐рж╕рзНржЯрзЗржо ржЕржирзЗржХ **responsive** ржоржирзЗ рж╣рзЯред  
ржпрзЗржоржи тАФ **ржЧрж╛ржи рж╢рзЛржирж╛, ржлрж╛ржЗрж▓ ржбрж╛ржЙржирж▓рзЛржб, ржУрзЯрж╛рж░рзНржб ржкрзНрж░рж╕рзЗрж╕рж┐ржВ** ржПржХрж╕рж╛ржерзЗ ржХрж░рж╛ ржпрж╛рзЯред

---

### ЁЯз▒ Fault Isolation (рждрзНрж░рзБржЯрж┐ ржкрзГржержХрзАржХрж░ржг)
ржкрзНрж░рждрж┐ржЯрж┐ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржмрж╛ ржЯрж╛рж╕рзНржХ ржЖрж▓рж╛ржжрж╛ memory space ржП ржЪрж▓рзЗред  
ржлрж▓рзЗ ржПржХржЯрж┐ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо **ржХрзНрж░рзНржпрж╛рж╢ ржХрж░рж▓рзЗржУ ржЕржирзНржпржЧрзБрж▓рзЛ ржкрзНрж░ржнрж╛ржмрж┐ржд рж╣рзЯ ржирж╛**, ржПржмржВ **system stability** ржмржЬрж╛рзЯ ржерж╛ржХрзЗред

---

### тЪЩя╕П Efficient Use of Hardware (рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░рзЗрж░ ржжржХрзНрж╖ ржмрзНржпржмрж╣рж╛рж░)
ржПржХрж╛ржзрж┐ржХ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржПржХрж╕рж╛ржерзЗ рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░ рж╢рзЗрзЯрж╛рж░ ржХрж░рзЗред  
ржПрждрзЗ **hardware utilization ржмрж╛рзЬрзЗ** ржПржмржВ ржХржо ржЦрж░ржЪрзЗ **scalable performance** ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯред

---

## ЁЯФ┤ Challenges and Limitations (ржЪрзНржпрж╛рж▓рзЗржЮрзНржЬ ржУ рж╕рзАржорж╛ржмржжрзНржзрждрж╛)

### тЪФя╕П Resource Contention (рж░рж┐рж╕рзЛрж░рзНрж╕ ржкрзНрж░рждрж┐ржпрзЛржЧрж┐рждрж╛)
ржПржХрж╛ржзрж┐ржХ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржПржХржЗ рж╕ржорзЯрзЗ CPU, Memory ржмрж╛ I/O device ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржЪрж╛ржЗрж▓рзЗ  
**resource starvation** рж╣рждрзЗ ржкрж╛рж░рзЗ тАФ ржХрзЛржирзЛ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржкрзНрж░рзЯрзЛржЬржирзАрзЯ рж░рж┐рж╕рзЛрж░рзНрж╕ ржирж╛ ржкрзЗрзЯрзЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗред

---

### ЁЯзо Overhead of Context Switching (Context Switch ржПрж░ ржЕрждрж┐рж░рж┐ржХрзНржд ржЦрж░ржЪ)
ржмрж╛рж░ржмрж╛рж░ task ржкрж░рж┐ржмрж░рзНрждржирзЗрж░ рж╕ржорзЯ CPU registers ржУ state save/restore ржХрж░рждрзЗ рж╣рзЯред  
ржПржЗ **context switching** ржпржжрж┐ ржШржи ржШржи рж╣рзЯ, рждрж╛рж╣рж▓рзЗ **system performance ржХржорзЗ ржпрж╛рзЯ**ред

---

### ЁЯФД Complex Synchronisation (ржЬржЯрж┐рж▓ рж╕рж┐ржЩрзНржХрзНрж░рзЛржирж╛ржЗржЬрзЗрж╢ржи)
ржПржХрж╛ржзрж┐ржХ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржПржХрж╕рж╛ржерзЗ shared data ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж▓рзЗ  
**data inconsistency**, **race condition**, ржмрж╛ **deadlock** рж╣рждрзЗ ржкрж╛рж░рзЗред

---

### ЁЯУИ Scalability Challenges (ржмрзЬ рж╕рж┐рж╕рзНржЯрзЗржорзЗ рж╕ржорж╕рзНржпрж╛)
рж╣рж╛ржЬрж╛рж░ рж╣рж╛ржЬрж╛рж░ concurrent task manage ржХрж░рж╛ ржХржарж┐ржиред  
рж╕рж┐рж╕рзНржЯрзЗржо ржмрзЬ рж╣рж▓рзЗ **performance, reliability, scalability** ржмржЬрж╛рзЯ рж░рж╛ржЦрж╛ ржЬржЯрж┐рж▓ рж╣рзЯрзЗ ржкрзЬрзЗред

---

## ЁЯФБ Context Switching (ржХржиржЯрзЗржХрзНрж╕ржЯ рж╕рзБржЗржЪрж┐ржВ)

### ЁЯзй Definition:
**Context Switching** рж╣рж▓рзЛ ржПржоржи ржПржХржЯрж┐ ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛ ржпрзЗржЦрж╛ржирзЗ CPU ржмрж░рзНрждржорж╛ржи task-ржПрж░ state save ржХрж░рзЗ ржПржмржВ ржкрж░ржмрж░рзНрждрзА task-ржПрж░ state restore ржХрж░рзЗ,  
ржпрж╛рждрзЗ CPU ржПржХржЗ рж╕ржорзЯрзЗ ржПржХрж╛ржзрж┐ржХ ржХрж╛ржЬ efficiently ржкрж░рж┐ржЪрж╛рж▓ржирж╛ ржХрж░рждрзЗ ржкрж╛рж░рзЗред

---

### ЁЯФ╣ Details:
- ржПржЯрж┐ CPU registers, memory pointers ржЗрждрзНржпрж╛ржжрж┐ рж╕ржВрж░ржХрзНрж╖ржг ржУ ржкрзБржирж░рзБржжрзНржзрж╛рж░ ржХрж░рзЗред  
- **Multitasking OS** context switching-ржПрж░ ржорж╛ржзрзНржпржорзЗ ржПржХрж╛ржзрж┐ржХ task ржПржХрж╕рж╛ржерзЗ ржЪрж╛рж▓рж╛рждрзЗ ржкрж╛рж░рзЗред  
- ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржХрж╛ржЫрзЗ ржоржирзЗ рж╣рзЯ ржпрзЗржи рж╕ржм ржХрж╛ржЬ **ржПржХрж╕рж╛ржерзЗ ржЪрж▓ржЫрзЗ**ред

---

## ЁЯТ╝ Use Cases (ржмрзНржпржмрж╣рж╛рж░рзЗрж░ ржХрзНрж╖рзЗрждрзНрж░)

| **Use Case** | **Description (ржмрж┐ржмрж░ржг)** |
|---------------|--------------------------|
| **User Applications** | ржПржХржЬржи ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржПржХрж╕рж╛ржерзЗ ржЧрж╛ржи рж╢рзБржирждрзЗ, ржбржХрзБржорзЗржирзНржЯ рж▓рж┐ржЦрждрзЗ, ржПржмржВ ржлрж╛ржЗрж▓ ржбрж╛ржЙржирж▓рзЛржб ржХрж░рждрзЗ ржкрж╛рж░рзЗржи тАФ OS ржПржЗ рж╕ржм ржХрж╛ржЬржХрзЗ рж╕рзБржирзНржжрж░ржнрж╛ржмрзЗ manage ржХрж░рзЗред |
| **Servers (рж╕рж╛рж░рзНржнрж╛рж░ рж╕рж┐рж╕рзНржЯрзЗржо)** | ржПржХржЯрж┐ Web Server ржПржХржЗ рж╕ржорзЯрзЗ ржПржХрж╛ржзрж┐ржХ ржЗржЙржЬрж╛рж░рзЗрж░ request рж╣рзНржпрж╛ржирзНржбрзЗрж▓ ржХрж░рждрзЗ ржкрж╛рж░рзЗ тАФ Multitasking ржПрж░ ржЬржирзНржп ржкрзНрж░рждрж┐ржЯрж┐ ржЗржЙржЬрж╛рж░ рж╕ржорзЯржорждрзЛ response ржкрж╛рзЯред |
| **Background Processes** | ржпрзЗржоржи: рж╕рж┐рж╕рзНржЯрзЗржо ржЖржкржбрзЗржЯ ржмрж╛ ржмрзНржпрж╛ржХржЖржк ржХрж╛ржЬ ржмрзНржпрж╛ржХржЧрзНрж░рж╛ржЙржирзНржбрзЗ ржЪрж▓рждрзЗ ржерж╛ржХрзЗ, ржЖрж░ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржЕржирзНржп ржЕрзНржпрж╛ржкрзНрж▓рж┐ржХрзЗрж╢ржи ржЪрж╛рж▓рж╛рждрзЗ ржкрж╛рж░рзЗржи ржирж┐рж░рзНржмрж┐ржШрзНржирзЗред |

---

ЁЯза **In Short:**  
тЮбя╕П Multiprogramming ржПржмржВ Multitasking OS ржПрж░ ржорзВрж▓ рж▓ржХрзНрж╖рзНржп тАФ **CPU utilization ржмрзГржжрзНржзрж┐, ржжрзНрж░рзБржд ржкрзНрж░рждрж┐ржХрзНрж░рж┐рзЯрж╛, ржПржмржВ efficient multitasking ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рж╛ред**

---


# тЪЩя╕П Kernel Mode and User Mode (ржХрж╛рж░рзНржирзЗрж▓ ржорзЛржб ржУ ржЗржЙржЬрж╛рж░ ржорзЛржб)

---

## ЁЯза Introduction (ржкрж░рж┐ржЪрж┐рждрж┐)

### ЁЯЧгя╕П English:
In an operating system, **modes** define the level of access that programs or processes have to system resources.  
There are mainly **two modes of operation тАФ Kernel Mode and User Mode**.  
These modes help the OS maintain **security, stability, and process isolation**.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
Operating System-ржП тАЬModeтАЭ ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рзЗ ржПржХржЯрж┐ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржмрж╛ ржкрзНрж░рж╕рзЗрж╕ рж╕рж┐рж╕рзНржЯрзЗржо рж░рж┐рж╕рзЛрж░рзНрж╕рзЗ ржХрждржЯрзБржХрзБ ржЕржзрж┐ржХрж╛рж░ (access) ржкрж╛ржмрзЗред  
ржжрзБржЗ ржзрж░ржирзЗрж░ ржорзЛржб ржерж╛ржХрзЗ тАФ **Kernel Mode** ржПржмржВ **User Mode**ред  
ржПржЗ ржжрзБржЯрж┐ ржорзЛржб рж╕рж┐рж╕рзНржЯрзЗржорзЗрж░ **ржирж┐рж░рж╛ржкрждрзНрждрж╛ (security)**, **рж╕рзНржерж┐рждрж┐рж╢рзАрж▓рждрж╛ (stability)** ржПржмржВ **process isolation** ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзЗред

---
# тЪЩя╕П Kernel in Operating System (ржХрж╛рж░рзНржирзЗрж▓ ржХрзА)

---

## ЁЯза Definition (рж╕ржВржЬрзНржЮрж╛)

### ЁЯЧгя╕П English:
The **Kernel** is the core component of an Operating System that acts as a bridge between hardware and software.  
It manages system resources like CPU, memory, and input/output devices, and ensures that applications can run smoothly without directly accessing hardware.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
**Kernel** рж╣рж▓рзЛ Operating System-ржПрж░ ржорзВрж▓ ржЕржВрж╢, ржпрж╛ **рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░ ржУ рж╕ржлржЯржУрзЯрзНржпрж╛рж░рзЗрж░ ржорж╛ржЭрзЗ рж╕рзЗрждрзБржмржирзНржзржи** рж╣рж┐рж╕рзЗржмрзЗ ржХрж╛ржЬ ржХрж░рзЗред  
ржПржЯрж┐ CPU, ржорзЗржорж░рж┐, ржЗржиржкрзБржЯ/ржЖржЙржЯржкрзБржЯ ржбрж┐ржнрж╛ржЗрж╕рж╕рж╣ рж╕ржорж╕рзНржд рж╕рж┐рж╕рзНржЯрзЗржо рж░рж┐рж╕рзЛрж░рзНрж╕ ржирж┐рзЯржирзНрждрзНрж░ржг ржХрж░рзЗ,  
ржПржмржВ ржЗржЙржЬрж╛рж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржоржЧрзБрж▓рзЛ ржпрзЗржи рж╕рж░рж╛рж╕рж░рж┐ рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░ рж╕рзНржкрж░рзНрж╢ ржирж╛ ржХрж░рзЗ рждржмрзБржУ ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░рзЗ тАФ рждрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзЗред

---

## ЁЯзй Functions of Kernel (Kernel-ржПрж░ ржкрзНрж░ржзрж╛ржи ржХрж╛ржЬ)

| Function | English Explanation | ржмрж╛ржВрж▓рж╛ ржмрзНржпрж╛ржЦрзНржпрж╛ |
|----------|-------------------|----------------|
| Process Management | Manages creation, scheduling, and termination of processes. | ржкрзНрж░рж╕рзЗрж╕ рждрзИрж░рж┐, рж╕ржорзЯ ржирж┐рж░рзНржзрж╛рж░ржг (scheduling), ржУ ржмржирзНржз ржХрж░рж╛рж░ ржХрж╛ржЬ ржХрж░рзЗред |
| Memory Management | Allocates and deallocates memory space for programs. | ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗрж░ ржЬржирзНржп ржорзЗржорж░рж┐ ржмрж░рж╛ржжрзНржж ржУ ржорзБржХрзНржд ржХрж░рж╛рж░ ржжрж╛рзЯрж┐рждрзНржмрзЗ ржерж╛ржХрзЗред |
| Device Management | Controls communication between devices and software through device drivers. | ржбрж┐ржнрж╛ржЗрж╕ ржбрзНрж░рж╛ржЗржнрж╛рж░ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж╕ржлржЯржУрзЯрзНржпрж╛рж░ ржУ рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░рзЗрж░ ржпрзЛржЧрж╛ржпрзЛржЧ ржирж┐рзЯржирзНрждрзНрж░ржг ржХрж░рзЗред |
| File Management | Handles file storage, retrieval, and access permissions. | ржлрж╛ржЗрж▓ рж╕ржВрж░ржХрзНрж╖ржг, ржкрзЬрж╛, рж▓рзЗржЦрж╛ ржПржмржВ ржкрж╛рж░ржорж┐рж╢ржи ржирж┐рзЯржирзНрждрзНрж░ржг ржХрж░рзЗред |
| System Call Handling | Provides an interface for user applications to request OS services. | ржЗржЙржЬрж╛рж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржоржХрзЗ OS рж╕рж╛рж░рзНржнрж┐рж╕ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛рж░ ржкрже ржжрзЗрзЯ (system call ржПрж░ ржорж╛ржзрзНржпржорзЗ)ред |

---

## тЪЩя╕П How Kernel Works (Kernel ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ)

### ЁЯЧгя╕П English:
When a user program needs hardware access (like reading a file or printing), it cannot do so directly.  
It sends a **system call** to the kernel.  
The kernel performs that action using device drivers, returns the result to the user program, and continues execution.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
ржпржЦржи ржХрзЛржирзЛ ржЗржЙржЬрж╛рж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржХрж░рждрзЗ ржЪрж╛рзЯ (ржпрзЗржоржи ржлрж╛ржЗрж▓ ржкрзЬрж╛ ржмрж╛ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рж╛),  
рж╕рзЗржЯрж┐ рж╕рж░рж╛рж╕рж░рж┐ ржХрж░рждрзЗ ржкрж╛рж░рзЗ ржирж╛ред  
рждржЦржи ржПржЯрж┐ **system call** ржПрж░ ржорж╛ржзрзНржпржорзЗ Kernel-ржХрзЗ ржЕржирзБрж░рзЛржз ржХрж░рзЗред  
Kernel ржХрж╛ржЬржЯрж┐ ржбрж┐ржнрж╛ржЗрж╕ ржбрзНрж░рж╛ржЗржнрж╛рж░ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж╕ржорзНржкржирзНржи ржХрж░рзЗ, рждрж╛рж░ржкрж░ ржлрж▓рж╛ржлрж▓ ржЗржЙржЬрж╛рж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржоржХрзЗ ржжрзЗрзЯред

### ЁЯТб Example:

```
User Program тЖТ System Call тЖТ Kernel тЖТ Hardware тЖТ Kernel тЖТ Result тЖТ User Program
```

---

## ЁЯзй Types of Kernel (Kernel-ржПрж░ ржкрзНрж░ржХрж╛рж░ржнрзЗржж)

| Type | Description (English) | ржмрж╛ржВрж▓рж╛ ржмрзНржпрж╛ржЦрзНржпрж╛ |
|------|----------------------|----------------|
| Monolithic Kernel | Entire OS (device drivers, memory management, etc.) runs in one big kernel space. | рж╕ржм OS ржЕржВрж╢ (ржбрзНрж░рж╛ржЗржнрж╛рж░, ржорзЗржорж░рж┐ ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ ржЗрждрзНржпрж╛ржжрж┐) ржПржХржЗ ржмрзЬ ржЬрж╛рзЯржЧрж╛рзЯ ржЪрж▓рзЗ, ржжрзНрж░рзБржд ржХрж┐ржирзНрждрзБ ржЬржЯрж┐рж▓ред |
| Microkernel | Only essential parts run in kernel space; others run in user space. | рж╢рзБржзрзБ ржкрзНрж░рзЯрзЛржЬржирзАрзЯ ржЕржВрж╢ ржХрж╛рж░рзНржирзЗрж▓рзЗ ржерж╛ржХрзЗ, ржмрж╛ржХрж┐ржЧрзБрж▓рзЛ ржЗржЙржЬрж╛рж░ рж╕рзНржкрзЗрж╕рзЗ ржЪрж▓рзЗ тАФ ржирж┐рж░рж╛ржкржж ржХрж┐ржирзНрждрзБ рждрзБрж▓ржирж╛ржорзВрж▓ржХ ржзрзАрж░ред |
| Hybrid Kernel | Combination of Monolithic and Microkernel. | Monolithic ржУ Microkernel ржжрзБржЗрзЯрзЗрж░ рж╕рзБржмрж┐ржзрж╛ ржорж┐рж▓рж┐рзЯрзЗ рждрзИрж░рж┐ред (ржпрзЗржоржи Windows NT, macOS) |
| Nanokernel | Extremely small kernel with minimal functionality. | ржЦрзБржм ржЫрзЛржЯ ржЖржХрж╛рж░рзЗрж░ ржХрж╛рж░рзНржирзЗрж▓, рж╢рзБржзрзБ ржорзМрж▓рж┐ржХ ржлрж┐ржЪрж╛рж░ ржерж╛ржХрзЗред |
| Exokernel | Gives applications direct control over hardware. | ржЕрзНржпрж╛ржкрзНрж▓рж┐ржХрзЗрж╢ржиржЧрзБрж▓рзЛржХрзЗ рж╕рж░рж╛рж╕рж░рж┐ рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржжрзЗрзЯ (research ржмрж╛ high-performance system-ржП ржмрзНржпржмрж╣рзГржд)ред |

---

## ЁЯза Examples of Kernel in Real Systems

| Operating System | Kernel Type |
|-----------------|------------|
| Linux | Monolithic Kernel |
| macOS | Hybrid Kernel |
| Windows | Hybrid Kernel |
| QNX | Microkernel |
| Minix | Microkernel |
| Android | Modified Linux Kernel |

---

## ЁЯзй Advantages of Having a Kernel

### ЁЯЧгя╕П English:
- Efficient resource management  
- Improved security and isolation  
- Better multitasking and process control  
- Smooth communication between hardware and software  

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
- рж░рж┐рж╕рзЛрж░рзНрж╕ ржЧрзБрж▓рзЛ ржХрж╛рж░рзНржпржХрж░ржнрж╛ржмрзЗ ржмрзНржпржмрж╣рж╛рж░ рж╣рзЯ  
- рж╕рж┐рж╕рзНржЯрзЗржо ржирж┐рж░рж╛ржкрждрзНрждрж╛ ржУ ржЖрж▓рж╛ржжрж╛ ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛ ржмржЬрж╛рзЯ ржерж╛ржХрзЗ  
- ржПржХрж╛ржзрж┐ржХ ржХрж╛ржЬ ржПржХрж╕рж╛ржерзЗ ржХрж░рж╛ рж╕рж╣ржЬ рж╣рзЯ  
- рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░ ржУ рж╕ржлржЯржУрзЯрзНржпрж╛рж░-ржПрж░ ржоржзрзНржпрзЗ рж╕ржарж┐ржХ ржпрзЛржЧрж╛ржпрзЛржЧ ржирж┐рж╢рзНржЪрж┐ржд рж╣рзЯ  

---

## тЪая╕П If Kernel Fails (ржпржжрж┐ Kernel ржмрзНржпрж░рзНрже рж╣рзЯ)

- If the kernel crashes тЖТ the **entire system stops working**  
- ржмрж╛ржВрж▓рж╛рзЯ: Kernel ржХрзНрж░рзНржпрж╛рж╢ ржХрж░рж▓рзЗ ржкрзБрж░рзЛ рж╕рж┐рж╕рзНржЯрзЗржо ржмржирзНржз рж╣рзЯрзЗ ржпрж╛рзЯ, рждрж╛ржЗ ржПржХрзЗ OS-ржПрж░ **тАЬрж╣рзГржжрзЯтАЭ** ржмрж▓рж╛ рж╣рзЯ тЭдя╕П


## ЁЯзй 1. Kernel Mode (ржХрж╛рж░рзНржирзЗрж▓ ржорзЛржб)

### ЁЯза English Explanation:
**Kernel Mode** is a **privileged mode** where the operating system has **full access** to all hardware and memory.  
All critical system operations тАФ such as:

- Memory management  
- Process scheduling  
- Device control  

тАФ happen in this mode.

If an error occurs in Kernel Mode, it can **crash the entire system** because it runs with high privileges.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛ ржмрзНржпрж╛ржЦрзНржпрж╛:
**Kernel Mode** рж╣рж▓рзЛ ржПржХржЯрж┐ **ржЙржЪрзНржЪ-ржЕржзрж┐ржХрж╛рж░рж╕ржорзНржкржирзНржи (privileged)** ржорзЛржб,  
ржпрзЗржЦрж╛ржирзЗ OS-ржПрж░ рж╕ржорзНржкрзВрж░рзНржг рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░ ржУ ржорзЗржорж░рж┐ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржерж╛ржХрзЗред  
рж╕ржм ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг ржХрж╛ржЬ ржпрзЗржоржи:

- ржорзЗржорж░рж┐ ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ  
- ржкрзНрж░рж╕рзЗрж╕ рж╢рж┐ржбрж┐ржЙрж▓рж┐ржВ  
- ржбрж┐ржнрж╛ржЗрж╕ ржХржирзНржЯрзНрж░рзЛрж▓  

ржПржЗ ржорзЛржбрзЗржЗ рж╕ржорзНржкржирзНржи рж╣рзЯред  
ржПржЗ ржорзЛржбрзЗ ржХрзЛржирзЛ рждрзНрж░рзБржЯрж┐ ржШржЯрж▓рзЗ **ржкрзБрж░рзЛ рж╕рж┐рж╕рзНржЯрзЗржо ржХрзНрж░рзНржпрж╛рж╢** ржХрж░рждрзЗ ржкрж╛рж░рзЗ, ржХрж╛рж░ржг ржПржЯрж┐ ржЙржЪрзНржЪ ржкрж░рзНржпрж╛рзЯрзЗрж░ ржПржХрзНрж╕рзЗрж╕ ржирж┐рзЯрзЗ ржХрж╛ржЬ ржХрж░рзЗред

### ЁЯТб Example:
When the OS executes **system calls** (like `read()`, `write()`, or memory allocation),  
it switches to **Kernel Mode** to perform those actions.

---

## ЁЯСд 2. User Mode (ржЗржЙржЬрж╛рж░ ржорзЛржб)

### ЁЯза English Explanation:
**User Mode** is a **restricted mode** where user applications run with **limited access** to system resources.  
Programs cannot directly interact with hardware or memory тАФ  
they must **request services** from the OS via **system calls**.

If a program crashes in User Mode, it does **not affect the entire OS**, ensuring safety and stability.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛ ржмрзНржпрж╛ржЦрзНржпрж╛:
**User Mode** рж╣рж▓рзЛ ржПржХржЯрж┐ **рж╕рзАржорж┐ржд ржХрзНрж╖ржорждрж╛рж╕ржорзНржкржирзНржи (restricted)** ржорзЛржб,  
ржпрзЗржЦрж╛ржирзЗ рж╕рж╛ржзрж╛рж░ржг ржЗржЙржЬрж╛рж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржЪрж▓рзЗред  
ржПржЗ ржорзЛржбрзЗ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо **рж╕рж░рж╛рж╕рж░рж┐ рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░ ржмрж╛ ржорзЗржорж░рж┐ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржХрж░рждрзЗ ржкрж╛рж░рзЗ ржирж╛**,  
ржмрж░ржВ OS-ржПрж░ ржХрж╛ржЫрзЗ **system call** ржПрж░ ржорж╛ржзрзНржпржорзЗ ржЕржирзБрж░рзЛржз ржкрж╛ржарж╛рзЯред

ржПрж░ ржлрж▓рзЗ, ржХрзЛржирзЛ ржЗржЙржЬрж╛рж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржХрзНрж░рзНржпрж╛рж╢ ржХрж░рж▓рзЗ **ржкрзБрж░рзЛ рж╕рж┐рж╕рзНржЯрзЗржорзЗ ржкрзНрж░ржнрж╛ржм ржкрзЬрзЗ ржирж╛**,  
ржЕрж░рзНржерж╛рзО рж╕рж┐рж╕рзНржЯрзЗржо **ржирж┐рж░рж╛ржкржж ржерж╛ржХрзЗ**ред

### ЁЯТб Example:
ржпржЦржи рждрзБржорж┐ ржХрзЛржирзЛ ржЕрзНржпрж╛ржк ржЦрзБрж▓рзЗ Word ржбржХрзБржорзЗржирзНржЯ рж▓рзЗржЦрзЛ, рж╕рзЗржЯрж╛ **User Mode**-ржП ржЪрж▓рзЗред

---

## ЁЯФД Mode Switching (ржорзЛржб ржкрж░рж┐ржмрж░рзНрждржи)

### ЁЯза English:
When a program in User Mode needs to perform a **system-level task** (like accessing a file or allocating memory),  
it uses a **System Call**, which temporarily switches the CPU from **User Mode тЖТ Kernel Mode**,  
executes the required operation, and then **switches back to User Mode**.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
ржпржЦржи ржХрзЛржирзЛ ржЗржЙржЬрж╛рж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо рж╕рж┐рж╕рзНржЯрзЗржо-рж▓рзЗржнрзЗрж▓ ржХрж╛ржЬ ржХрж░рждрзЗ ржЪрж╛рзЯ (ржпрзЗржоржи ржлрж╛ржЗрж▓ ржкрзЬрж╛, рж▓рзЗржЦрж╛ ржмрж╛ ржорзЗржорж░рж┐ ржмрж░рж╛ржжрзНржж),  
рждржЦржи CPU рж╕рж╛ржорзЯрж┐ржХржнрж╛ржмрзЗ **User Mode тЖТ Kernel Mode**-ржП ржпрж╛рзЯ,  
ржХрж╛ржЬржЯрж┐ рж╢рзЗрж╖ ржХрж░рзЗ ржЖржмрж╛рж░ **User Mode**-ржП ржлрж┐рж░рзЗ ржЖрж╕рзЗред

### тЪЩя╕П Example:
```
User Program тЖТ (System Call) тЖТ Kernel Mode тЖТ Task Done тЖТ Back to User Mode
```
---

## ЁЯз╛ Comparison Table (рждрзБрж▓ржирж╛ржорзВрж▓ржХ рж╕рж╛рж░ржгрж┐)

| **Feature** | **Kernel Mode** | **User Mode** |
|--------------|-----------------|----------------|
| **Access Level** | Full access to system resources | Limited access |
| **Executed By** | Operating System | User Applications |
| **Direct Hardware Access** | тЬЕ Yes | тЭМ No |
| **Privilege Level** | High | Low |
| **Error Impact** | Can crash the whole system | Affects only that program |
| **Examples** | Memory Management, Process Scheduling | Running Chrome, VS Code, Games |

---

## ЁЯза Summary (рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж╕рж╛рж░рж╛ржВрж╢)

- ЁЯФ╣ **Kernel Mode** = System control, full access  
- ЁЯФ╣ **User Mode** = User applications, limited access  
- ЁЯФ╣ **Mode Switching** ensures both **performance** and **protection**

---


# тЪЩя╕П System Calls (рж╕рж┐рж╕рзНржЯрзЗржо ржХрж▓)

---

## ЁЯза Definition (рж╕ржВржЬрзНржЮрж╛)

### ЁЯЧгя╕П English:
A **System Call** is an interface provided by the operating system that allows a user program to request services from the kernel.  
It acts as a bridge between **User Mode** and **Kernel Mode**, enabling programs to perform tasks that they cannot execute directly.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
**System Call** рж╣рж▓рзЛ ржПржХржЯрж┐ ржмрж┐рж╢рзЗрж╖ ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ ржпрж╛ OS ржкрзНрж░ржжрж╛ржи ржХрж░рзЗ, ржпрж╛рждрзЗ **User Program** Kernel ржерзЗржХрзЗ ржкрзНрж░рзЯрзЛржЬржирзАрзЯ рж╕рж╛рж░рзНржнрж┐рж╕ ржирж┐рждрзЗ ржкрж╛рж░рзЗред  
ржПржЯрж┐ **User Mode тЖФ Kernel Mode** ржПрж░ ржоржзрзНржпрзЗ рж╕рзЗрждрзБржмржирзНржзржи рж╣рж┐рж╕рзЗржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ,  
ржпрж╛рж░ ржорж╛ржзрзНржпржорзЗ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржПржоржи ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░рзЗ ржпрж╛ рж╕рж░рж╛рж╕рж░рж┐ ржХрж░рждрзЗ ржкрж╛рж░ржмрзЗ ржирж╛ред

---

## ЁЯзй How System Calls Work (ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ)

1. A user program needs a service (e.g., read a file, write data, create a process).  
2. It executes a system call, which triggers a mode switch from **User Mode тЖТ Kernel Mode**.  
3. Kernel performs the requested operation using hardware and OS resources.  
4. Result or status is returned to the user program, CPU switches back to **User Mode**.

### ЁЯЗзЁЯЗй ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ:
1. ржХрзЛржирзЛ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо рж╕рж╛рж░рзНржнрж┐рж╕ ржЪрж╛рзЯ (ржпрзЗржоржи ржлрж╛ржЗрж▓ ржкрзЬрж╛ ржмрж╛ рж▓рзЗржЦрж╛, ржкрзНрж░рж╕рзЗрж╕ рждрзИрж░рж┐ ржХрж░рж╛)ред  
2. ржкрзНрж░рзЛржЧрзНрж░рж╛ржо **system call** ржХрж░рзЗ, ржлрж▓рзЗ CPU **User Mode тЖТ Kernel Mode** ржП ржЪрж▓рзЗ ржпрж╛рзЯред  
3. Kernel ржХрж╛ржЬржЯрж┐ рж╕ржорзНржкржирзНржи ржХрж░рзЗред  
4. ржлрж▓рж╛ржлрж▓ ржмрж╛ рж╕рзНржЯрзНржпрж╛ржЯрж╛рж╕ ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗ ржлрзЗрж░ржд ржпрж╛рзЯ, CPU ржЖржмрж╛рж░ **User Mode** ржП ржлрж┐рж░рзЗ ржЖрж╕рзЗред

### ЁЯТб Diagram:
```
User Program тЖТ System Call тЖТ Kernel тЖТ Hardware/OS тЖТ Kernel тЖТ Result тЖТ User Program
```


---

## ЁЯзй Types of System Calls (рж╕рж┐рж╕рзНржЯрзЗржо ржХрж▓рзЗрж░ ржзрж░ржи)

| Type | English Explanation | ржмрж╛ржВрж▓рж╛ ржмрзНржпрж╛ржЦрзНржпрж╛ |
|------|-------------------|----------------|
| Process Control | Create, terminate, suspend, resume processes | ржкрзНрж░рж╕рзЗрж╕ рждрзИрж░рж┐, ржмржирзНржз ржХрж░рж╛, ржерж╛ржорж╛ржирзЛ ржмрж╛ ржЪрж╛рж▓рзБ ржХрж░рж╛ |
| File Management | Open, read, write, close files | ржлрж╛ржЗрж▓ ржЦрзЛрж▓рж╛, ржкрзЬрж╛, рж▓рзЗржЦрж╛, ржмржирзНржз ржХрж░рж╛ |
| Device Management | Request device, release device | ржбрж┐ржнрж╛ржЗрж╕ ржмрзНржпржмрж╣рж╛рж░ ржЪрж╛ржУрзЯрж╛ ржмрж╛ ржорзБржХрзНржд ржХрж░рж╛ |
| Information Maintenance | Get system time, get process info | рж╕рж┐рж╕рзНржЯрзЗржо рж╕ржорзЯ, ржкрзНрж░рж╕рзЗрж╕рзЗрж░ рждржерзНржп ржкрж╛ржУрзЯрж╛ |
| Communication | Send/receive messages between processes | ржкрзНрж░рж╕рзЗрж╕рзЗрж░ ржоржзрзНржпрзЗ рждржерзНржп ржЖржжрж╛ржи-ржкрзНрж░ржжрж╛ржи |

---

## ЁЯза Examples (ржЙржжрж╛рж╣рж░ржг)

| Operation | English | ржмрж╛ржВрж▓рж╛ |
|-----------|---------|-------|
| File | open(), read(), write(), close() | ржлрж╛ржЗрж▓ ржЦрзЛрж▓рж╛, ржкрзЬрж╛, рж▓рзЗржЦрж╛, ржмржирзНржз ржХрж░рж╛ |
| Process | fork(), exit(), wait() | ржирждрзБржи ржкрзНрж░рж╕рзЗрж╕ рждрзИрж░рж┐, ржкрзНрж░рж╕рзЗрж╕ ржмржирзНржз, ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рж╛ |
| Device | ioctl() | ржбрж┐ржнрж╛ржЗрж╕ ржирж┐рзЯржирзНрждрзНрж░ржг |
| Info | getpid(), time() | ржкрзНрж░рж╕рзЗрж╕ ржЖржЗржбрж┐, рж╕рж┐рж╕рзНржЯрзЗржо рж╕ржорзЯ |

---

## тЬЕ Advantages (рж╕рзБржмрж┐ржзрж╛)

- Provides safe access to hardware from user programs  
- Ensures security and isolation between processes  
- Enables efficient multitasking and process control  
- Standard interface across different OS platforms  

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
- ржЗржЙржЬрж╛рж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗрж░ ржЬржирзНржп рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░рзЗ ржирж┐рж░рж╛ржкржж ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржкрзНрж░ржжрж╛ржи  
- ржкрзНрж░рж╕рзЗрж╕ржЧрзБрж▓рзЛрж░ ржоржзрзНржпрзЗ ржирж┐рж░рж╛ржкрждрзНрждрж╛ ржУ ржЖрж▓рж╛ржжрж╛ рж░рж╛ржЦрзЗ  
- ржПржХрж╛ржзрж┐ржХ ржХрж╛ржЬ ржПржХрж╕рж╛ржерзЗ ржХрж░рж╛рж░ рж╕рзБржмрж┐ржзрж╛ ржжрзЗрзЯ  
- ржмрж┐ржнрж┐ржирзНржи OS-ржП **standard interface** ржкрзНрж░ржжрж╛ржи ржХрж░рзЗ

---

## тЪая╕П Note (ржоржирзЗ рж░рж╛ржЦрж╛рж░ ржмрж┐рж╖рзЯ)

- User programs cannot access hardware directly тЖТ **System Call is mandatory**  
- Each system call triggers **mode switch**, which has small CPU overhead

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
- ржЗржЙржЬрж╛рж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо рж╕рж░рж╛рж╕рж░рж┐ рж╣рж╛рж░рзНржбржУрзЯрзНржпрж╛рж░рзЗ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржХрж░рждрзЗ ржкрж╛рж░рзЗ ржирж╛ тЖТ рждрж╛ржЗ **System Call ржЕржкрж░рж┐рж╣рж╛рж░рзНржп**  
- ржкрзНрж░рждрж┐ржЯрж┐ system call **mode switch** ржХрж░рзЗ, ржпрж╛рж░ ржлрж▓рзЗ CPU-рждрзЗ рж╕рж╛ржорж╛ржирзНржп ржЕрждрж┐рж░рж┐ржХрзНржд рж▓рзЛржб рж╣рзЯ



# тЪЩя╕П Process and Its States (ржкрзНрж░рж╕рзЗрж╕ ржУ ржПрж░ ржЕржмрж╕рзНржерж╛)

---

## ЁЯза Definition of Process (ржкрзНрж░рж╕рзЗрж╕рзЗрж░ рж╕ржВржЬрзНржЮрж╛)

### ЁЯЧгя╕П English:
A **Process** is a program in execution. It is an active entity with a **program counter**, **CPU registers**, **memory**, and **state information**.  
Each process performs a specific task and goes through various states during its lifecycle.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
**ржкрзНрж░рж╕рзЗрж╕** рж╣рж▓рзЛ ржПржХржЯрж┐ ржХрж╛рж░рзНржпржХрж░рзА ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржпрж╛ CPU-рждрзЗ ржЪрж▓ржЫрзЗред  
ржкрзНрж░рж╕рзЗрж╕рзЗрж░ ржерж╛ржХрзЗ:

- Program Counter (ржкрж░ржмрж░рзНрждрзА instruction ржХрзЛржерж╛ ржерзЗржХрзЗ execute рж╣ржмрзЗ)  
- CPU Registers  
- Memory Allocation  
- State Information  

ржкрзНрж░рж╕рзЗрж╕ ржЬрзАржмржжрзНржжрж╢рж╛ржпрж╝ ржмрж┐ржнрж┐ржирзНржи ржЕржмрж╕рзНржерж╛ (states) ржПрж░ ржоржзрзНржп ржжрж┐ржпрж╝рзЗ ржпрж╛ржпрж╝ред

---

## ЁЯзй Process States (ржкрзНрж░рж╕рзЗрж╕рзЗрж░ ржЕржмрж╕рзНржерж╛)

### 1я╕ПтГг New (ржирждрзБржи)
- **English:** The process is being created. OS allocates resources but it has not started execution yet.  
- **ржмрж╛ржВрж▓рж╛:** ржкрзНрж░рж╕рзЗрж╕ рждрзИрж░рж┐ рж╣ржЪрзНржЫрзЗред OS ржХрж┐ржЫрзБ resource ржмрж░рж╛ржжрзНржж ржХрж░рзЗ, рждржмрзЗ execution рж╢рзБрж░рзБ рж╣ржпрж╝ржирж┐ред

### 2я╕ПтГг Ready (ржкрзНрж░рж╕рзНрждрзБржд)
- **English:** The process is loaded into main memory and is waiting for CPU. It is ready to run but CPU is not yet allocated.  
- **ржмрж╛ржВрж▓рж╛:** ржкрзНрж░рж╕рзЗрж╕ ржорзЗржорж░рж┐рждрзЗ рж▓рзЛржб рж╣рзЯрзЗ ржЖржЫрзЗ ржПржмржВ CPU ржкрж╛ржУрзЯрж╛рж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрзЗред Execution рж╢рзБрж░рзБ рж╣рзЯржирж┐, рждржмрзЗ рж╕ржм resource ржкрзНрж░рж╕рзНрждрзБрждред

### 3я╕ПтГг Running (ржЪрж▓ржЫрзЗ)
- **English:** The CPU is currently executing the process instructions. Only one process per CPU runs at a time.  
- **ржмрж╛ржВрж▓рж╛:** CPU ржмрж░рзНрждржорж╛ржирзЗ ржкрзНрж░рж╕рзЗрж╕ржЯрж┐ execute ржХрж░ржЫрзЗред ржПржХ рж╕ржорзЯрзЗ ржПржХ CPU-рждрзЗ ржХрзЗржмрж▓ ржПржХржЯрж┐ ржкрзНрж░рж╕рзЗрж╕ ржЪрж▓рждрзЗ ржкрж╛рж░рзЗред

### 4я╕ПтГг Waiting / Blocked (ржЕржкрзЗржХрзНрж╖ржорж╛ржг / ржмрзНрж▓ржХржб)
- **English:** The process cannot continue until some event occurs, such as I/O completion or resource availability.  
- **ржмрж╛ржВрж▓рж╛:** ржкрзНрж░рж╕рзЗрж╕ржЯрж┐ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрзЗ ржХрж╛рж░ржг ржХрж┐ржЫрзБ event ржШржЯрждрзЗ рж╣ржмрзЗ (ржпрзЗржоржи: I/O ржХрж╛ржЬ рж╢рзЗрж╖ рж╣ржУржпрж╝рж╛ ржмрж╛ resource ржкрж╛ржУрзЯрж╛)ред

### 5я╕ПтГг Terminated / Exit (рж╢рзЗрж╖ / ржЯрж╛рж░рзНржорж┐ржирзЗржЯ)
- **English:** The process has finished execution and is removed from memory. All allocated resources are released.  
- **ржмрж╛ржВрж▓рж╛:** ржкрзНрж░рж╕рзЗрж╕ execution рж╢рзЗрж╖ ржХрж░рзЗржЫрзЗ ржПржмржВ ржорзЗржорж░рж┐ ржерзЗржХрзЗ рж╕рж░рж╛ржирзЛ рж╣ржпрж╝рзЗржЫрзЗред ржмрж░рж╛ржжрзНржжржХрзГржд рж╕ржорж╕рзНржд resource ржорзБржХрзНржд ржХрж░рж╛ рж╣рзЯред

---

## ЁЯФД Process State Diagram (ржкрзНрж░рж╕рзЗрж╕ рж╕рзНржЯрзЗржЯ ржбрж╛ржпрж╝рж╛ржЧрзНрж░рж╛ржо)
sql
Copy code
    +---------+
    |  New    |
    +---------+
         |
         v
    +---------+
    | Ready   | <----+
    +---------+      |
         |           |
         v           |
    +---------+      |
    | Running |      |
    +---------+      |
     |    |          |
     |    v          |
     | Waiting       |
     +---------+     |
         |           |
         +-----------+
         |
         v
     Terminated
sql
Copy code

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛ ржмрзНржпрж╛ржЦрзНржпрж╛:
New тЖТ Ready тЖТ Running тЖТ Waiting тЖТ Ready (ржпржжрж┐ ржЖржмрж╛рж░ CPU ржЪрж╛рзЯ) тЖТ Terminated

---

## ЁЯзй Key Points (ржорзВрж▓ ржмрж┐рж╖рзЯржЧрзБрж▓рзЛ)

- A process is dynamic, unlike a program which is static.  
  **ржмрж╛ржВрж▓рж╛:** ржкрзНрж░рж╕рзЗрж╕ dynamic, ржкрзНрж░рзЛржЧрзНрж░рж╛ржо staticред

- **Process Control Block (PCB)** contains all information about a process: PID, State, CPU registers, Memory pointers, I/O status.  
  **ржмрж╛ржВрж▓рж╛:** PCB-ржП ржерж╛ржХрзЗ ржкрзНрж░рж╕рзЗрж╕рзЗрж░ рж╕ржм рждржерзНржп: PID, State, CPU registers, Memory pointer, I/O statusред

- Only one process per CPU runs at a time in Running state.  
  **ржмрж╛ржВрж▓рж╛:** ржПржХ рж╕ржорзЯрзЗ ржХрзЗржмрж▓ ржПржХржЯрж┐ ржкрзНрж░рж╕рзЗрж╕ CPU-рждрзЗ ржЪрж▓рждрзЗ ржкрж╛рж░рзЗред
  