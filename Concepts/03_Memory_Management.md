
# ЁЯза Memory Management in Operating System (ржорзЗржорж░рж┐ ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ)

---

## ЁЯзй Definition (рж╕ржВржЬрзНржЮрж╛)

### ЁЯЧгя╕П English:
Memory Management is a process by which the operating system keeps track of each byte in a computerтАЩs memory and allocates memory to processes efficiently.  
It ensures that each process has enough memory to execute while maximizing CPU utilization and system performance.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
ржорзЗржорж░рж┐ ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ рж╣рж▓рзЛ ржПржХржЯрж┐ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ ржпрж╛рж░ ржорж╛ржзрзНржпржорзЗ OS ржкрзНрж░рждрж┐ржЯрж┐ memory byte-ржХрзЗ track ржХрж░рзЗ ржПржмржВ processes-ржХрзЗ memory efficientржнрж╛ржмрзЗ allocate ржХрж░рзЗред  
ржПрждрзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржкрзНрж░рж╕рзЗрж╕ execution-ржПрж░ ржЬржирзНржп ржкрж░рзНржпрж╛ржкрзНржд memory ржкрж╛ржпрж╝ ржПржмржВ system performance ржмрж╛рзЬрзЗред

---

## ЁЯФ╣ Objectives of Memory Management (ржЙржжрзНржжрзЗрж╢рзНржп)

- Allocate memory to processes efficiently  
- Keep track of free and allocated memory  
- Maximize CPU utilization  
- Avoid memory fragmentation  

**ржмрж╛ржВрж▓рж╛:**

- Processes-ржХрзЗ memory efficientржнрж╛ржмрзЗ ржмрж░рж╛ржжрзНржж ржХрж░рж╛  
- Free ржУ allocated memory track рж░рж╛ржЦрж╛  
- CPU utilization ржмрж╛рзЬрж╛ржирзЛ  
- Memory fragmentation ржХржорж╛ржирзЛ  

---

## ЁЯзй Memory Allocation Techniques (ржорзЗржорж░рж┐ ржмрж░рж╛ржжрзНржжрзЗрж░ ржкржжрзНржзрждрж┐)

Memory allocation ржкрзНрж░ржзрж╛ржиржд **dynamic partitioning**-ржП рждрж┐ржиржнрж╛ржмрзЗ ржХрж░рж╛ рж╣рзЯ:

### 1я╕ПтГг First Fit (ржлрж╛рж░рзНрж╕рзНржЯ ржлрж┐ржЯ)

**English:** Allocate the first block of memory that is large enough to satisfy the request.  
**ржмрж╛ржВрж▓рж╛:** ржкрзНрж░ржержорзЗ ржпрзЗ memory block request-ржПрж░ ржЬржирзНржп ржпржерзЗрж╖рзНржЯ ржмрзЬ, рж╕рзЗржЯрж┐рждрзЗ allocation ржХрж░рж╛ рж╣рзЯред  

**Example:**

Memory Blocks: 100 KB, 500 KB, 200 KB, 300 KB  
Process P1 needs 212 KB тЖТ Allocated to 500 KB block (first suitable block)  

**Advantages:** Fast allocation, simple  
**Disadvantages:** May cause external fragmentation  

---

### 2я╕ПтГг Best Fit (ржмрзЗрж╕рзНржЯ ржлрж┐ржЯ)

**English:** Allocate the smallest block that is large enough to satisfy the request.  
**ржмрж╛ржВрж▓рж╛:** рж╕ржмржЪрзЗрзЯрзЗ ржЫрзЛржЯ memory block-ржП allocation ржХрж░рж╛ рж╣рзЯ ржпрж╛ request ржкрзВрж░ржг ржХрж░рждрзЗ ржкрж╛рж░рзЗред  

**Example:**

Memory Blocks: 100 KB, 500 KB, 200 KB, 300 KB  
Process P1 needs 212 KB тЖТ Allocated to 300 KB block (best fit)  

**Advantages:** Minimizes wasted space  
**Disadvantages:** Can be slower, may create many small unusable holes  

---

### 3я╕ПтГг Worst Fit (ржУрзЯрж╛рж░рж╕рзНржЯ ржлрж┐ржЯ)

**English:** Allocate the largest available block to the process.  
**ржмрж╛ржВрж▓рж╛:** рж╕ржмржЪрзЗрзЯрзЗ ржмрзЬ memory block-ржП allocation ржХрж░рж╛ рж╣рзЯред  

**Example:**

Memory Blocks: 100 KB, 500 KB, 200 KB, 300 KB  
Process P1 needs 212 KB тЖТ Allocated to 500 KB block (largest block)  

**Advantages:** Reduces chance of small unusable fragments  
**Disadvantages:** May leave very large unused blocks, not efficient  

---

## ЁЯФ╣ Summary Table (рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк)

| Technique   | How it works                 | Advantages                     | Disadvantages                   |
|------------|------------------------------|--------------------------------|--------------------------------|
| First Fit  | First block тЙе request        | Fast, simple                   | External fragmentation          |
| Best Fit   | Smallest block тЙе request     | Minimizes waste                | Slower, many small holes        |
| Worst Fit  | Largest block тЙе request      | Less small fragments           | Wastes large memory blocks      |

---

## ЁЯФС Key Points (ржорзВрж▓ ржмрж┐рж╖рзЯ)

- Memory allocation can be **static (fixed)** or **dynamic (variable)**  
- Fragmentation = **external** (unused small holes) + **internal** (unused space in allocated block)  
- First Fit, Best Fit, Worst Fit тЖТ simple dynamic allocation strategies  
- Modern OS may use **paging / segmentation** to overcome fragmentation

---
# ЁЯза Virtual Memory (ржнрж╛рж░рзНржЪрзБржпрж╝рж╛рж▓ ржорзЗржорж░рж┐)

---

## ЁЯзй Definition (рж╕ржВржЬрзНржЮрж╛)

### ЁЯЧгя╕П English:
Virtual Memory is a memory management technique in which the operating system gives the illusion of more memory than physically available by using a combination of RAM and secondary storage (like HDD/SSD).  
It allows processes to run even if they donтАЩt completely fit into physical memory.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
ржнрж╛рж░рзНржЪрзБржпрж╝рж╛рж▓ ржорзЗржорж░рж┐ рж╣рж▓рзЛ ржПржоржи ржПржХржЯрж┐ memory management technique ржпрзЗржЦрж╛ржирзЗ OS ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржжрзЗрж░ ржЕржзрж┐ржХ memory ржЖржЫрзЗ ржмрж▓рзЗ illusion ржжрзЗрзЯ, RAM ржПржмржВ secondary storage (HDD/SSD) ржПржХрж╕рж╛ржерзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗред  
ржПржЯрж┐ ржПржоржи ржкрзНрж░рж╕рзЗрж╕ржХрзЗ ржЪрж▓рждрзЗ ржжрзЗрзЯ ржпрзЗржЧрзБрж▓рзЛ ржкрзВрж░рзНржгржнрж╛ржмрзЗ physical memory-рждрзЗ ржлрж┐ржЯ рж╣рзЯ ржирж╛ред

---

## ЁЯФ╣ Objectives (ржЙржжрзНржжрзЗрж╢рзНржп)

- Allow execution of large programs beyond physical memory size  
- Provide memory isolation between processes  
- Increase CPU utilization by overlapping I/O and computation  
- Reduce fragmentation using paging or segmentation  

**ржмрж╛ржВрж▓рж╛:**

- ржмрзЬ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржЪрж╛рж▓рж╛ржирзЛрж░ рж╕рзБржпрзЛржЧ ржжрзЗржУрзЯрж╛  
- Processes-ржПрж░ ржоржзрзНржпрзЗ memory isolation ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рж╛  
- I/O ржУ computation overlap ржХрж░рзЗ CPU utilization ржмрзГржжрзНржзрж┐  
- Paging / Segmentation ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ fragmentation ржХржорж╛ржирзЛ  

---

## ЁЯзй How Virtual Memory Works (ржХрж┐ржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ)

1. **Logical / Virtual Address**  
   Programs use virtual addresses, not physical addresses.

2. **Memory Management Unit (MMU)**  
   Translates virtual addresses тЖТ physical addresses.

3. **Page Table**  
   Keeps track of which virtual pages are in physical memory.

4. **Paging / Segmentation**  
   Memory is divided into fixed-size pages or variable-size segments.  
   Only required pages/segments are loaded into RAM; rest stay in secondary storage.

---

## ЁЯФ╣ Advantages (рж╕рзБржмрж┐ржзрж╛)

| English | ржмрж╛ржВрж▓рж╛ |
|---------|-------|
| Run programs larger than RAM | RAM-ржПрж░ ржЪрзЗрзЯрзЗ ржмрзЬ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржЪрж╛рж▓рж╛ржирзЛ ржпрж╛рзЯ |
| Efficient use of memory | Memory efficiently ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ ржпрж╛рзЯ |
| Provides process isolation | Processes ржПржХрзЗ ржЕржкрж░ржХрзЗ disturb ржХрж░рзЗ ржирж╛ |
| Simplifies memory management | Memory management рж╕рж╣ржЬ рж╣рзЯ |

---

## ЁЯФ╣ Disadvantages (ржЕрж╕рзБржмрж┐ржзрж╛)

| English | ржмрж╛ржВрж▓рж╛ |
|---------|-------|
| Slower than RAM | RAM-ржПрж░ ржЪрзЗрзЯрзЗ ржзрзАрж░ |
| Overhead of page table management | Page table manage ржХрж░рж╛рж░ overhead |
| Can cause thrashing if too many page faults | ржЕржирзЗржХ page fault рж╣рж▓рзЗ system slow (thrashing) |

---

## ЁЯзй Example (ржЙржжрж╛рж╣рж░ржг)

Suppose a program needs 100 KB, but RAM has only 40 KB free.  

Virtual memory loads 40 KB pages into RAM, rest stays on disk.  
MMU swaps pages in/out as needed тЖТ program runs as if 100 KB memory is available.

---

## ЁЯФД Virtual Memory Diagram

Process Virtual Address
--------------------> Page Table ----------------> Physical Address (RAM)
|
v
Disk (Secondary Storage)

yaml
Copy code

**ржмрж╛ржВрж▓рж╛:**

Process virtual address тЖТ Page Table тЖТ RAM / Disk  
Page fault рж╣рж▓рзЗ required page HDD ржерзЗржХрзЗ RAM-ржП load рж╣рзЯ

---

## ЁЯФС Key Points (ржорзВрж▓ ржмрж┐рж╖рзЯ)

- Virtual Memory = RAM + Secondary Storage illusion  
- Paging / Segmentation = main techniques  
- Supports large programs, multitasking, isolation  
- Critical for modern OS efficiency
---
### тЪЩя╕П What is Thrashing

**Thrashing** is a condition in an operating system where the system spends an excessive amount of time swapping pages between main memory (RAM) and secondary storage (like a hard disk) instead of performing useful work, leading to severe performance degradation.

When the system continuously moves data between **RAM** and **disk (swap space)** due to insufficient physical memory, the CPU becomes busy doing memory management instead of actual processing.

This makes the system **very slow** and **unresponsive**.


<br>

**Thrashing** рж╣ржЪрзНржЫрзЗ ржПржоржи ржПржХржЯрж┐ ржЕржмрж╕рзНржерж╛ ржпрзЗржЦрж╛ржирзЗ ржХржорзНржкрж┐ржЙржЯрж╛рж░рзЗрж░ **RAM-ржПрж░ ржЬрж╛рзЯржЧрж╛ ржХржо ржерж╛ржХрж╛рж░ ржХрж╛рж░ржгрзЗ**  
Operating System ржмрж╛рж░ржмрж╛рж░ ржбрзЗржЯрж╛ **RAM ржерзЗржХрзЗ ржбрж┐рж╕рзНржХрзЗ (swap area)** ржкрж╛ржарж╛рзЯ ржПржмржВ ржЖржмрж╛рж░ ржлрж┐рж░рж┐рзЯрзЗ ржЖржирзЗред

ЁЯзй **ржлрж▓рж╛ржлрж▓:**  
CPU ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржЪрж╛рж▓рж╛ржирзЛрж░ ржЪрзЗрзЯрзЗ ржмрзЗрж╢рж┐ рж╕ржорзЯ ржмрзНржпрзЯ ржХрж░рзЗ **ржорзЗржорж░рж┐ ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯрзЗ (page swapping)**,  
ржпрж╛рж░ ржХрж╛рж░ржгрзЗ рж╕рж┐рж╕рзНржЯрзЗржо ржЦрзБржм ржзрзАрж░рзЗ ржЪрж▓рзЗ ржмрж╛ **рж╣рзНржпрж╛ржВ** ржХрж░рзЗред



### ЁЯза Example (Easy to Imagine)

ржзрж░рзЛ, рждрзЛржорж╛рж░ ржХржорзНржкрж┐ржЙржЯрж╛рж░рзЗ **4 GB RAM** ржЖржЫрзЗред  
рждрзБржорж┐ ржПржХрж╕рж╛ржерзЗ **Chrome, VS Code, Photoshop, ржПржмржВ ржПржХржЯрж╛ ржмрзЬ ржЧрзЗржо** ржЪрж╛рж▓рж╛ржЪрзНржЫрзЛ ЁЯОо  

ЁЯСЙ рждржЦржи OS ржмрж╛рж░ржмрж╛рж░ data load ржХрж░ржЫрзЗ тАФ  
ржПржХржЯрж╛ ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗрж░ data RAM-ржП ржжрж┐ржЪрзНржЫрзЗ, ржЕржирзНржпржЯрж╛рж░ржЯрж╛ ржбрж┐рж╕рзНржХрзЗ ржкрж╛ржарж╛ржЪрзНржЫрзЗред  
ржПржЗ **swap in/out** ржЪрж▓рждрзЗ ржерж╛ржХрзЗ ржмрж╛рж░ржмрж╛рж░ тАФ  
ржлрж▓рзЗ CPU рж╢рзБржзрзБ data shuffle ржХрж░рждрзЗ ржмрзНржпрж╕рзНржд, **ржЖрж╕рж▓ ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░ржЫрзЗ ржирж╛**ред  

тЮбя╕П ржПржЗ ржЕржмрж╕рзНржерж╛ржЗ **Thrashing**ред

<br>

### ЁЯй╣ Solutions / Prevention

| ЁЯз░ Solution | ЁЯУЭ Description |
|-------------|----------------|
| **Reduce the degree of multiprogramming** | Run fewer programs at a time. |
| **Add more RAM** | Increase physical memory to reduce swapping. |
| **Use better page replacement algorithms** | Example: **LRU (Least Recently Used)** algorithm helps reduce unnecessary swapping. |
| **Adjust system workload** | Distribute tasks or delay heavy programs to balance memory load. |



ЁЯУЪ **Summary:**  
Thrashing occurs when a system is overwhelmed by memory swapping.  
It slows performance drastically, but can be prevented by managing memory efficiently and keeping the system workload balanced.



<br>

# ЁЯза Memory Allocation Techniques (ржорзЗржорж░рж┐ ржмрж░рж╛ржжрзНржжрзЗрж░ ржкржжрзНржзрждрж┐)

---

## 1я╕ПтГг Contiguous Memory Allocation (ржПржХржЯрж╛ржирж╛ ржорзЗржорж░рж┐ ржмрж░рж╛ржжрзНржж)

### ЁЯЧгя╕П English:
In contiguous allocation, each process is allocated a single continuous block of memory. CPU can easily calculate addresses within the block, so access is fast.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
ржПржХржЯрж╛ржирж╛ ржорзЗржорж░рж┐ ржмрж░рж╛ржжрзНржжрзЗ, ржкрзНрж░рждрж┐ржЯрж┐ ржкрзНрж░рж╕рзЗрж╕ржХрзЗ ржПржХржЯрж┐ ржПржХржЯрж╛ржирж╛ memory block ржмрж░рж╛ржжрзНржж ржХрж░рж╛ рж╣рзЯред CPU рж╕рж╣ржЬрзЗржЗ addresses calculate ржХрж░рждрзЗ ржкрж╛рж░рзЗ, рждрж╛ржЗ access ржжрзНрж░рзБржд рж╣рзЯред

### Advantages:
- Simple and fast  
- Easy address calculation  

### Disadvantages:
- External fragmentation: Total free memory may exist but not contiguous  
- Internal fragmentation: Allocated block slightly larger than needed тЖТ wasted space  
- Requires fitting strategies: First Fit, Best Fit, Worst Fit  

---

## 2я╕ПтГг Paging (ржкрзЗржЬрж┐ржВ)

### ЁЯЧгя╕П English:
Paging divides physical memory into fixed-size blocks called frames and logical memory into pages of the same size. Pages can be loaded into any available frame, tracked by a page table.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
ржкрзЗржЬрж┐ржВ-ржП physical memory ржХрзЗ fixed-size blocks (frames) ржП ржнрж╛ржЧ ржХрж░рж╛ рж╣рзЯ ржПржмржВ logical memory ржХрзЗ ржПржХржЗ ржЖржХрж╛рж░рзЗрж░ pages ржП ржнрж╛ржЧ ржХрж░рж╛ рж╣рзЯред  
ржкрзНрж░рждрж┐ржЯрж┐ page ржпрзЗржХрзЛржирзЛ available frame-ржП load ржХрж░рж╛ ржпрж╛рзЯ, ржПржмржВ page table mapping рж░рж╛ржЦрзЗред

### Advantages:
- Solves external fragmentation  
- Efficient memory allocation  
- Allows larger programs via virtual memory  
- Simplifies allocation algorithms  

### Disadvantages:
- Page table consumes memory  
- Page table lookup adds slight delay  
- Internal fragmentation may occur in last page  

### Diagram:
Logical Memory (Pages) тЖТ Page Table тЖТ Physical Memory (Frames)

yaml
Copy code

---

## 3я╕ПтГг Segmentation (рж╕рзЗржЧржорзЗржирзНржЯрзЗрж╢ржи)

### ЁЯЧгя╕П English:
Segmentation divides process memory into variable-sized segments, each representing a logical unit (function, array, data structure). Each segment has a segment number and offset.

### ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛:
рж╕рзЗржЧржорзЗржирзНржЯрзЗрж╢ржи-ржП process memory ржХрзЗ variable-size segments-ржП ржнрж╛ржЧ ржХрж░рж╛ рж╣рзЯред ржкрзНрж░рждрж┐ржЯрж┐ segment logical unit (function, array, data structure) рж╣рждрзЗ ржкрж╛рж░рзЗред  
ржкрзНрж░рждрж┐ржЯрж┐ segment-ржПрж░ ржПржХржЯрж┐ segment number ржПржмржВ offset ржерж╛ржХрзЗред

### Advantages:
- Reflects programтАЩs logical structure  
- Supports protection and sharing  
- Reduces wasted space within segments  

### Disadvantages:
- May cause external fragmentation  
- Allocation/deallocation algorithms are complex  

---

## ЁЯФ╣ Paging vs Segmentation

| Feature | Paging | Segmentation |
|---------|--------|--------------|
| Memory Division | Fixed-size pages | Variable-size segments |
| Physical Memory | Frames (same size as pages) | Segments of varying sizes |
| Address Structure | Page number + offset | Segment number + offset |
| Fragmentation | No external, may have internal | External possible, no internal |
| Logical Division | Ignores logical structure | Follows logical structure |
| Management | Simpler | More complex |
| Protection & Sharing | Easier at page level | Logical, but complex |
| Access Time | Uniform | Varies per segment |
| Use Case | Modern OS, virtual memory | Specific apps needing logical division |

---

## ЁЯФС Key Points (ржорзВрж▓ ржмрж┐рж╖рзЯ)

- **Contiguous**: Simple, fast, but fragmentation problems  
- **Paging**: Eliminates external fragmentation, uses page table, suitable for virtual memory  
- **Segmentation**: Logical grouping, better modularity, may cause external fragmentation  
- Modern OS often combines **paging + segmentation** for efficient memory management

---

### ЁЯУШ What is Paging?


**Paging** is a memory management technique used by the **Operating System** to store and manage processes in memory efficiently.  
In this system, both the **physical memory (RAM)** and **logical memory (process)** are divided into fixed-size blocks тАФ  
- ЁЯСЙ **Pages** (for process memory)  
- ЁЯСЙ **Frames** (for physical memory)

When a process is executed, its pages are loaded into available frames in the physical memory.  

ЁЯОп **Goal:** To avoid memory fragmentation and make memory allocation easier.


<br>

**Paging** рж╣рж▓рзЛ ржПржХржЯрж┐ **Memory Management Technique**,  
ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо (**Logical Memory**) ржПржмржВ **RAM** (**Physical Memory**) тАФ  
ржжрзБржЯрзЛржХрзЗржЗ рж╕ржорж╛ржи ржЖржХрж╛рж░рзЗрж░ ржЫрзЛржЯ ржЫрзЛржЯ ржЕржВрж╢рзЗ ржнрж╛ржЧ ржХрж░рж╛ рж╣рзЯред  

- ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗрж░ ржкрзНрж░рждрж┐ржЯрж┐ ржЕржВрж╢ржХрзЗ ржмрж▓рж╛ рж╣рзЯ **Page**  
- RAM-ржПрж░ ржкрзНрж░рждрж┐ржЯрж┐ ржЕржВрж╢ржХрзЗ ржмрж▓рж╛ рж╣рзЯ **Frame**  

OS ржпржЦржи ржХрзЛржирзЛ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо рж░рж╛ржи ржХрж░рзЗ, рждржЦржи ржУржЗ ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗрж░ ржХрж┐ржЫрзБ **page** ржирж┐рзЯрзЗ **RAM**-ржПрж░ **frame**-ржП рж░рж╛ржЦрзЗред  
ржПржнрж╛ржмрзЗ ржкрзНрж░рзЛржЧрзНрж░рж╛ржоржЯрж┐ ржЫрзЛржЯ ржЫрзЛржЯ ржЯрзБржХрж░рж╛рзЯ RAM-ржП рж▓рзЛржб рж╣рзЯред



### ЁЯзй Visualization (Diagram Style)

```
ЁЯУж Process (Logical Memory)
 ------------------------
 | Page 1 | Page 2 | Page 3 | Page 4 |
 ------------------------

ЁЯТ╛ Physical Memory (RAM)
 ------------------------
 | Frame 5 | Frame 8 | Frame 2 | Frame 9 |
 ------------------------

тЮбя╕П Page 1 тЖТ Frame 5  
тЮбя╕П Page 2 тЖТ Frame 8  
тЮбя╕П Page 3 тЖТ Frame 2  
тЮбя╕П Page 4 тЖТ Frame 9
```
OS keeps a тАЬpage tableтАЭ тАФ that maps which page is in which frame

---

### ЁЯУШ What is a Page Fault?

A **Page Fault** occurs when a program tries to access a page that is **not currently in RAM**.  
Since that page is stored on the **disk (secondary storage)**, the **Operating System** must load it into RAM before continuing execution.  

ЁЯзй **In short:**  
`Page Fault = Page not in memory тЖТ OS loads it from disk`


**Page Fault** ржШржЯрзЗ ржпржЦржи ржХрзЛржирзЛ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржПржоржи ржПржХржЯрж┐ **page** ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржХрж░рждрзЗ ржЪрж╛рзЯ ржпрж╛ ржмрж░рзНрждржорж╛ржирзЗ **RAM**-ржП ржирзЗржЗред  
рждржЦржи **Operating System** рж╕рзЗржЯрж┐ **secondary storage (ржпрзЗржоржи Hard Disk)** ржерзЗржХрзЗ ржПржирзЗ **RAM**-ржП рж▓рзЛржб ржХрж░рзЗред  
ржПрждрзЗ ржХрж┐ржЫрзБржЯрж╛ рж╕ржорзЯ рж▓рж╛ржЧрзЗ, ржХрж╛рж░ржг **disk access** рж╣рж▓рзЛ **RAM**-ржПрж░ ржЪрзЗрзЯрзЗ ржЕржирзЗржХ ржзрзАрж░ред

<br>

### ЁЯФБ Page Fault Handling Steps (ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ ржХрзА ржШржЯрзЗ)

1. ЁЯза **CPU** tries to access a page  
2. ЁЯз╛ **OS checks** тАФ is that page in RAM?  
3. тЭМ If not found тЖТ a **Page Fault** occurs  
4. тП╕я╕П **OS pauses** the process  
5. ЁЯТ╛ **OS loads** the required page from **Disk тЖТ RAM**  
6. ЁЯЧВя╕П **Page Table** gets updated  
7. тЦ╢я╕П **Process resumes** execution  



### тЪб Visualization

```
ЁЯза CPU тЖТ needs Page 4
ЁЯУЛ OS checks Page Table тЭМ (not in RAM)
ЁЯТ╛ Load Page 4 from Disk тЖТ RAM тЬЕ
ЁЯФБ Update Page Table & Resume Execution
```

### ЁЯЪи Relationship Between Paging, Page Fault & Thrashing

|  **Concept** |  **Description** |
|----------------|--------------------|
| **Paging** | Divides memory into pages and frames. |
| **Page Fault** | Happens when a page is not in RAM and must be fetched from disk. |
| **Thrashing** | Occurs when page faults happen too frequently, making the CPU busy swapping pages. |



### ЁЯзй In short:
**Too many page faults тЖТ Thrashing тЖТ System slowdown**



### ЁЯТб Shortcut to Remember:
- ЁЯз▒ **Paging** тЖТ Divide memory  
- ЁЯЪл **Page Fault** тЖТ Page missing in RAM  
- ЁЯФБ **Thrashing** тЖТ Too many page faults


---
# ЁЯза Dynamic Binding (ржбрж╛ржЗржирж╛ржорж┐ржХ ржмрж╛ржЗржирзНржбрж┐ржВ)

---

## ЁЯзй Definition (рж╕ржВржЬрзНржЮрж╛)

### English:
Dynamic Binding (also called late binding) is a process where the method or function to be invoked is determined at runtime, rather than at compile time.  
It allows flexibility and polymorphism in object-oriented programming, enabling different behaviors for different objects.

### ржмрж╛ржВрж▓рж╛:
ржбрж╛ржЗржирж╛ржорж┐ржХ ржмрж╛ржЗржирзНржбрж┐ржВ (late binding) рж╣рж▓рзЛ ржПржоржи ржПржХржЯрж┐ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ ржпрзЗржЦрж╛ржирзЗ ржХрзЛржи method ржмрж╛ function call ржХржЦржи execute рж╣ржмрзЗ рждрж╛ runtime-ржП ржирж┐рж░рзНржзрж╛рж░рж┐ржд рж╣рзЯ, compile time-ржП ржирзЯред  
ржПржЯрж┐ flexibility ржПржмржВ polymorphism ржкрзНрж░ржжрж╛ржи ржХрж░рзЗ, ржЕрж░рзНржерж╛рзО ржПржХржЗ interface ржмрж╛ function ржмрж┐ржнрж┐ржирзНржи object ржЕржирзБржпрж╛рзЯрзА ржнрж┐ржирзНржиржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рждрзЗ ржкрж╛рж░рзЗред

---

## ЁЯФ╣ Key Features (ржорзВрж▓ ржмрзИрж╢рж┐рж╖рзНржЯрзНржп)

| Feature | English | ржмрж╛ржВрж▓рж╛ |
|---------|---------|-------|
| Binding Time | Runtime (Late Binding) | рж░рж╛ржиржЯрж╛ржЗржо (ржжрзЗрж░рж┐рждрзЗ ржирж┐рж░рзНржзрж╛рж░ржг) |
| Supports | Polymorphism | Polymorphism рж╕ржорж░рзНржержи ржХрж░рзЗ |
| Flexibility | High, method can change at runtime | ржмрзЗрж╢рж┐, runtime-ржП method ржкрж░рж┐ржмрж░рзНрждржи рж╣рждрзЗ ржкрж╛рж░рзЗ |
| Commonly Used | Virtual functions in C++, method overriding in Java | C++ ржП virtual function, Java-ржП method overriding ржП ржмрзНржпржмрж╣рзГржд |

---

## ЁЯФ╣ Example (ржЙржжрж╛рж╣рж░ржг)

### English (Java Example):
```java
class Animal {
    void sound() 
    {
         System.out.println("Animal makes sound"); 
    }
}

class Dog extends Animal {
    void sound() 
    {
         System.out.println("Dog barks"); 
    }
}

public class Main {
    public static void main(String[] args) 
    {
        Animal a = new Dog(); // reference type Animal, object type Dog
        a.sound(); // Dynamic binding тЖТ prints "Dog barks"
    }
}
```
Explanation:
- Reference type = Animal

- Object type = Dog

- Method sound() is resolved at runtime тЖТ Dog version executes



ЁЯФ╣ Advantages (рж╕рзБржмрж┐ржзрж╛)
- Supports polymorphism тЖТ ржПржХ interface, multiple implementations

- Provides flexibility in program behavior

- Enables method overriding and dynamic decision-making

ЁЯФ╣ Disadvantages (ржЕрж╕рзБржмрж┐ржзрж╛)
- Slightly slower than static binding (compile-time)

- Debugging may be harder due to runtime resolution

ЁЯФС Key Points (ржорзВрж▓ ржмрж┐рж╖рзЯ)
- Dynamic Binding = runtime method resolution

- Opposite of Static Binding (compile-time method resolution)

- Essential for OOP concepts like polymorphism and inheritance

---


### ЁЯУШ What is Segmentation?

Segmentation is a **memory management technique** in which a program is divided into **variable-sized parts** called **segments**.  
Each segment represents a **logical unit** of the program тАФ like functions, arrays, or data structures.  

Unlike paging (where all blocks are of equal size),  
ЁЯСЙ in segmentation, each segment has a **different size** depending on the programтАЩs structure.

**Example:**  
A program may have тАФ  
- Code segment  
- Data segment  
- Stack segment  
- Heap segment  



Segmentation рж╣рж▓рзЛ ржПржоржи ржПржХржЯрж┐ **ржорзЗржорж░рж┐ ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ ржЯрзЗржХржирж┐ржХ**,  
ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рзЛржЧрзНрж░рж╛ржоржХрзЗ **ржнрж┐ржирзНржи ржнрж┐ржирзНржи ржЖржХрж╛рж░рзЗрж░ ржЕржВрж╢рзЗ (segments)** ржнрж╛ржЧ ржХрж░рж╛ рж╣рзЯред  
ржкрзНрж░рждрж┐ржЯрж┐ segment рж╣рж▓рзЛ ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗрж░ ржПржХржЯрж┐ **рж▓ржЬрж┐ржХрзНржпрж╛рж▓ ржЕржВрж╢** тАФ ржпрзЗржоржи code, data, stack ржЗрждрзНржпрж╛ржжрж┐ред  
ЁЯСЙ Paging-ржПрж░ ржорждрзЛ рж╕ржм ржЕржВрж╢ рж╕ржорж╛ржи ржЖржХрж╛рж░рзЗрж░ ржирзЯ,  
ржкрзНрж░рждрж┐ржЯрж┐ segment-ржПрж░ ржЖржХрж╛рж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗрж░ ржкрзНрж░рзЯрзЛржЬржи ржЕржирзБржпрж╛рзЯрзА ржнрж┐ржирзНржи рж╣рзЯред



### ЁЯзй Visualization (Diagram Style)

```
Program (Logical View)
-----------------------------------
| Code Segment | Data Segment | Stack Segment |
-----------------------------------

Physical Memory (RAM)
-----------------------------------
| Segment 2 | Segment 1 | Segment 3 |
-----------------------------------
```

>OS keeps a Segment Table, which stores each segmentтАЩs base address and length.


### тЪЩя╕П Segment Table Example

| Segment | Base Address | Length |
|----------|--------------|--------|
| Code | 1000 | 600 |
| Data | 1600 | 400 |
| Stack | 2000 | 300 |

This tells the OS where each segment starts and how big it is.



### ЁЯза Difference Between Paging and Segmentation

|  **Feature** |  **Paging** | **Segmentation** |
|----------------|---------------|---------------------|
| **Basic Idea** | Divides memory into fixed-size blocks (pages). | Divides memory into variable-size blocks (segments). |
| **Block Name** | Pages (process) and Frames (RAM). | Segments (logical parts). |
| **Size** | Fixed for all pages. | Variable, depends on the logical structure. |
| **Type of Division** | Physical memory-based division. | Logical program-based division. |
| **Fragmentation** | May cause internal fragmentation. | May cause external fragmentation. |
| **Address Mapping** | Uses Page Table. | Uses Segment Table. |
| **Example** | Page 1, Page 2, Page 3тАж | Code segment, Data segment, Stack segmentтАж |
| **Used In** | Virtual memory systems. | Memory management in compilers and OS. |



### ЁЯОп Key Difference Summary

| **Paging** | **Segmentation** |
|-------------|------------------|
| Breaks memory into equal-sized pages. | Breaks program into logical parts (segments). |
| Concerned with **physical memory**. | Concerned with **program structure**. |
| Easier for **hardware management**. | Easier for **programmers to understand**. |


### ЁЯза Example to Remember (Analogy)

### ЁЯУЦ Think of a Book

| ЁЯзй **Concept** | ЁЯУШ **Explanation** |
|----------------|--------------------|
| **Paging** | Book is divided into equal-sized pages (fixed size). |
| **Segmentation** | Book is divided into chapters (different lengths, logically grouped). |



### ЁЯз╛ So,

ЁЯСЙ **Paging** = Fixed-size **physical** division  
ЁЯСЙ **Segmentation** = Variable-size **logical** division  


### тЪб Shortcut to Remember

ЁЯзй **Paging** тЖТ Fixed-size, *physical*  
ЁЯза **Segmentation** тЖТ Variable-size, *logical*


--
# ЁЯза Page Replacement Algorithms (ржкрзЗржЬ рж░рж┐ржкрзНрж▓рзЗрж╕ржорзЗржирзНржЯ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо)

---

## ЁЯзй Introduction (ржнрзВржорж┐ржХрж╛)

### English:
When a process requires a page that is not in physical memory (RAM), a page fault occurs. The OS must load the required page from disk. If RAM is full, an existing page must be replacedтАФthis is called Page Replacement.

### ржмрж╛ржВрж▓рж╛:
ржпржЦржи ржХрзЛржирзЛ ржкрзНрж░рж╕рзЗрж╕ ржПржоржи ржПржХржЯрж┐ ржкрзЗржЬ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржЪрж╛ржпрж╝ ржпрж╛ physical memory (RAM)-ржП ржирзЗржЗ, рждржЦржи page fault ржШржЯрзЗред  
RAM ржкрзВрж░рзНржг ржерж╛ржХрж▓рзЗ ржПржХржЯрж┐ ржкрзЗржЬ ржкрзНрж░рждрзНржпрж╛рж╣рж╛рж░ (replace) ржХрж░рждрзЗ рж╣рзЯред ржПржЗ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ржЯрж┐ржХрзЗржЗ Page Replacement ржмрж▓рзЗред

---

## ЁЯФ╣ Important Terms (ржорзВрж▓ рж╢ржмрзНржж)

| Term | English | ржмрж╛ржВрж▓рж╛ |
|------|---------|-------|
| Page Fault | Requested page not in memory | RAM-ржП ржкрзЗржЬ ржирзЗржЗ |
| Frame | Fixed-size block in RAM | RAM-ржПрж░ fixed-size block |
| Replacement | Choosing a page to remove | ржХрзЛржи ржкрзЗржЬ remove ржХрж░рж╛ рж╣ржмрзЗ рждрж╛ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рж╛ |

---

## 1я╕ПтГг FIFO (First In First Out)

### English:
Replace the page that entered memory first.  
Simple queue structure: oldest page replaced first.

### ржмрж╛ржВрж▓рж╛:
рж╕ржмржЪрзЗржпрж╝рзЗ ржкрзБрж░рж╛ржирзЛ ржкрзЗржЬ RAM-ржП ржерзЗржХрзЗ ржмрж╛ржж ржжрзЗржУржпрж╝рж╛ рж╣ржпрж╝ред  
Queue ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ implement ржХрж░рж╛ рж╣ржпрж╝ред

**Advantages:**  
- Simple and easy to implement  

**Disadvantages:**  
- May remove frequently used pages тЖТ BeladyтАЩs anomaly  

**Example:**  
Frames = 3, Page Reference: 7, 0, 1, 2, 0, 3, 0, 4  
FIFO Replacement Sequence: 7,0,1 replaced by 2 тЖТ page faults occur

---

## 2я╕ПтГг LRU (Least Recently Used)

### English:
Replace the page that has not been used for the longest time.  
Keeps track of usage history (stack, counter, or matrix).

### ржмрж╛ржВрж▓рж╛:
рж╕ржмржЪрзЗржпрж╝рзЗ ржжрзАрж░рзНржШ рж╕ржоржпрж╝ ржмрзНржпржмрж╣рж╛рж░ ржирж╛ рж╣ржУржпрж╝рж╛ ржкрзЗржЬ RAM-ржП ржерзЗржХрзЗ ржмрж╛ржж ржжрзЗржУржпрж╝рж╛ рж╣ржпрж╝ред  
Usage history maintain ржХрж░рждрзЗ рж╣ржпрж╝ред

**Advantages:**  
- Efficient тЖТ keeps frequently used pages in memory  

**Disadvantages:**  
- Slightly complex to implement  

**Example:**  
Frames = 3, Page Reference: 7,0,1,2,0,3,0,4  
LRU Replacement Sequence тЖТ remove least recently used page at each fault

---

## 3я╕ПтГг Optimal Page Replacement

### English:
Replace the page that will not be used for the longest time in the future.  
Gives minimum possible page faults тЖТ ideal, theoretical algorithm.

### ржмрж╛ржВрж▓рж╛:
ржПржоржи ржкрзЗржЬ remove ржХрж░рж╛ рж╣ржпрж╝ ржпрж╛ ржжрзВрж░ ржнржмрж┐рж╖рзНржпрждрзЗ ржмрзНржпржмрж╣рж╛рж░ рж╣ржмрзЗ ржирж╛ред  
Minimum page faults, ржХрж┐ржирзНрждрзБ real-time impossible, рж╢рзБржзрзБржорж╛рждрзНрж░ theoreticalред

**Example:**  
Frames = 3, Page Reference: 7,0,1,2,0,3,0,4  
Optimal тЖТ replace page whose next use is farthest

---

## ЁЯФ╣ Comparison Table (рждрзБрж▓ржирж╛)

| Algorithm | Strategy | Advantage | Disadvantage | Use Case |
|-----------|---------|-----------|--------------|----------|
| FIFO | Oldest page removed first | Simple | BeladyтАЩs anomaly | Simple systems |
| LRU | Least recently used removed | Efficient | Complex | Real systems, OS |
| Optimal | Farthest future use removed | Minimum page faults | Not practical | Theoretical benchmark |

---

## ЁЯФС Key Points (ржорзВрж▓ ржмрж┐рж╖рзЯ)

- Page Replacement is needed when RAM is full during page fault.  
- FIFO, LRU, Optimal are main strategies.  
- LRU тЙИ practical, Optimal = ideal  
- Efficient page replacement тЖТ better CPU utilization and reduced I/O
---
# ЁЯза Thrashing (ржерзНрж░рзНржпрж╛рж╢рж┐ржВ)

---

## ЁЯзй Definition (рж╕ржВржЬрзНржЮрж╛)

### English:
Thrashing occurs when a system spends more time swapping pages in and out of memory than executing actual processes.  
It usually happens when too many processes compete for limited physical memory, causing excessive page faults.

### ржмрж╛ржВрж▓рж╛:
ржерзНрж░рзНржпрж╛рж╢рж┐ржВ ржШржЯрзЗ ржпржЦржи system ржмрзЗрж╢рж┐ рж╕ржорзЯ pages swap ржХрж░рждрзЗ ржмрзНржпржпрж╝ ржХрж░рзЗ, ржХрж┐ржирзНрждрзБ ржкрзНрж░рж╕рзЗрж╕ржЧрзБрж▓рж┐ ржЪрж╛рж▓рж╛рждрзЗ ржкрж╛рж░рзЗ ржирж╛ред  
ржПржЯрж┐ рж╕рж╛ржзрж╛рж░ржгржд ржШржЯрзЗ ржпржЦржи ржЕржирзЗржХ ржкрзНрж░рж╕рзЗрж╕ рж╕рзАржорж┐ржд RAM-ржПрж░ ржЬржирзНржп ржкрзНрж░рждрж┐ржпрзЛржЧрж┐рждрж╛ ржХрж░рзЗ, ржлрж▓рзЗ ржЕржирзЗржХ page fault рж╣рзЯред

---

## ЁЯФ╣ Causes (ржХрж╛рж░ржг)

- **Overloaded Memory** тАУ too many processes loaded  
  **ржмрж╛ржВрж▓рж╛:** ржЕрждрж┐рж░рж┐ржХрзНржд ржкрзНрж░рж╕рзЗрж╕ ржорзЗржорж░рж┐рждрзЗ тАУ ржЕржирзЗржХ ржкрзНрж░рж╕рзЗрж╕ RAM-ржП рж▓рзЛржб рж╣рзЯ  

- **High Degree of Multiprogramming** тАУ CPU and memory contention  
  **ржмрж╛ржВрж▓рж╛:** Multiprogramming ржмрзЗрж╢рж┐ тАУ CPU ржУ memory ржЬржирзНржп contention  

- **Insufficient Physical Memory** тАУ large programs + small RAM  
  **ржмрж╛ржВрж▓рж╛:** ржкрзНрж░ржЪрзБрж░ ржмрзЬ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо + ржХржо RAM

---

## ЁЯФ╣ Effects (ржкрзНрж░ржнрж╛ржм)

- System performance drops drastically  
  **ржмрж╛ржВрж▓рж╛:** System performance ржЦрзБржм ржХржорзЗ ржпрж╛рзЯ  

- CPU utilization falls  
  **ржмрж╛ржВрж▓рж╛:** CPU utilization ржирзЗржорзЗ ржЖрж╕рзЗ  

- System becomes unresponsive  
  **ржмрж╛ржВрж▓рж╛:** System slow / hang рж╣рзЯрзЗ ржпрж╛рзЯ  

- High I/O activity due to constant paging  
  **ржмрж╛ржВрж▓рж╛:** Frequent I/O activity тЖТ constant paging

---

## ЁЯФ╣ Detection (рж╕ржирж╛ржХрзНрждржХрж░ржг)

- High page fault rate  
  **ржмрж╛ржВрж▓рж╛:** High page fault rate  

- CPU utilization decreases while I/O waits increase  
  **ржмрж╛ржВрж▓рж╛:** CPU utilization ржХржорзЗ ржпрж╛рзЯ, I/O wait ржмрзЗрзЬрзЗ ржпрж╛рзЯ  

- System throughput reduces  
  **ржмрж╛ржВрж▓рж╛:** System throughput ржХржорзЗ ржпрж╛рзЯ

---

## ЁЯФ╣ Prevention & Solution (ржкрзНрж░рждрж┐рж░рзЛржз ржПржмржВ рж╕ржорж╛ржзрж╛ржи)

- **Reduce Degree of Multiprogramming** тАУ load fewer processes  
  **ржмрж╛ржВрж▓рж╛:** Multiprogramming ржХржорж╛ржирзЛ тАУ ржХржо ржкрзНрж░рж╕рзЗрж╕ рж▓рзЛржб ржХрж░рж╛  

- **Increase Physical Memory** тАУ add RAM  
  **ржмрж╛ржВрж▓рж╛:** Physical Memory ржмрзГржжрзНржзрж┐ тАУ RAM ржмрж╛ржбрж╝рж╛ржирзЛ  

- **Use Local Page Replacement** тАУ limit page replacement to each process  
  **ржмрж╛ржВрж▓рж╛:** Local Page Replacement ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ тАУ ржкрзНрж░рждрж┐ржЯрж┐ ржкрзНрж░рж╕рзЗрж╕рзЗрж░ ржЬржирзНржп page replacement рж╕рзАржорж╛ржмржжрзНржз ржХрж░рж╛  

- **Working Set Model** тАУ maintain a set of pages each process actively uses  
  **ржмрж╛ржВрж▓рж╛:** Working Set Model тАУ ржкрзНрж░рждрж┐ржЯрж┐ ржкрзНрж░рж╕рзЗрж╕рзЗрж░ active pages рж░рж╛ржЦрж╛рж░ ржирж┐рзЯржо

---

## ЁЯФ╣ Key Points (ржорзВрж▓ ржмрж┐рж╖рзЯ)

- Thrashing тЖТ too many page faults + low CPU utilization  
- Usually caused by high multiprogramming + insufficient RAM  
- Prevention тЖТ control degree of multiprogramming & working set management  
- Critical for maintaining system performance

---
# ЁЯза Disk Scheduling (ржбрж┐рж╕рзНржХ рж╕рзНржХрзЗржЬрзБрж▓рж┐ржВ)

---

## ЁЯзй Definition (рж╕ржВржЬрзНржЮрж╛)

### English:
Disk Scheduling is the method used by an operating system to decide the order in which pending disk I/O requests are serviced.  
Efficient disk scheduling reduces seek time and improves throughput.

### ржмрж╛ржВрж▓рж╛:
ржбрж┐рж╕рзНржХ рж╕рзНржХрзЗржЬрзБрж▓рж┐ржВ рж╣рж▓рзЛ Operating System-ржПрж░ ржкржжрзНржзрждрж┐, ржпрж╛ ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рзЗ ржХрзЛржи disk I/O request ржЖржЧрзЗ рж╕рж╛рж░рзНржнрж┐рж╕ рж╣ржмрзЗред  
рж╕ржарж┐ржХ ржбрж┐рж╕рзНржХ рж╕рзНржХрзЗржЬрзБрж▓рж┐ржВ seek time ржХржорж╛рзЯ ржПржмржВ throughput ржмрж╛рзЬрж╛рзЯред

---

## ЁЯФ╣ Why Needed (ржХрзЗржи ржжрж░ржХрж╛рж░)

- Disk I/O is slower than CPU operations  
  **ржмрж╛ржВрж▓рж╛:** Disk I/O CPU-ржПрж░ рждрзБрж▓ржирж╛рзЯ ржзрзАрж░  

- Multiple requests may arrive simultaneously  
  **ржмрж╛ржВрж▓рж╛:** ржЕржирзЗржХ request ржПржХрж╕рж╛ржерзЗ ржЖрж╕рждрзЗ ржкрж╛рж░рзЗ  

- Efficient scheduling reduces average seek time  
  **ржмрж╛ржВрж▓рж╛:** Efficient scheduling average seek time ржХржорж╛рзЯ

---

## ЁЯФ╣ Common Disk Scheduling Algorithms (ржкрзНрж░ржЪрж▓рж┐ржд ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо)

| Algorithm | Strategy | Advantages | Disadvantages |
|-----------|---------|------------|---------------|
| FCFS (First Come First Serve) | Requests serviced in arrival order | Simple, fair | May increase seek time |
| SSTF (Shortest Seek Time First) | Request with shortest seek distance is serviced first | Reduces seek time | May cause starvation |
| SCAN (Elevator Algorithm) | Disk arm moves in one direction, servicing requests, then reverses | Fair, efficient | Long wait for far requests |
| C-SCAN (Circular SCAN) | Disk arm moves in one direction only, jumps back to start | Uniform wait time | Slightly more seek time than SCAN |
| LOOK / C-LOOK | Similar to SCAN/C-SCAN, but reverses at last request instead of end | Reduces unnecessary movement | Slightly complex |

---

## ЁЯФ╣ Example (FCFS)

- Disk Queue: 98, 183, 37, 122, 14, 124, 65, 67  
- Initial Head Position: 53  

**FCFS Sequence:** 53 тЖТ 98 тЖТ 183 тЖТ 37 тЖТ 122 тЖТ 14 тЖТ 124 тЖТ 65 тЖТ 67  

**Seek Time Calculation:**  
|53-98| + |98-183| + |183-37| + ... = Total Seek Time

---

## ЁЯФ╣ Key Points (ржорзВрж▓ ржмрж┐рж╖рзЯ)

- Disk scheduling reduces average seek time and improves throughput  
- SSTF, SCAN, C-SCAN, LOOK are more efficient than FCFS  
- Choice of algorithm depends on system workload and fairness requirements

---
# ЁЯза Disk Scheduling Algorithms (ржбрж┐рж╕рзНржХ рж╕рзНржХрзЗржЬрзБрж▓рж┐ржВ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо)

---

## ЁЯзй Introduction (ржнрзВржорж┐ржХрж╛)

### English:
Disk Scheduling Algorithms determine the order in which disk I/O requests are serviced. The goal is to minimise seek time and improve throughput.

### ржмрж╛ржВрж▓рж╛:
ржбрж┐рж╕рзНржХ рж╕рзНржХрзЗржЬрзБрж▓рж┐ржВ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рзЗ ржХрзЛржи disk I/O request ржЖржЧрзЗ рж╕рж╛рж░рзНржнрж┐рж╕ рж╣ржмрзЗред  
рж▓ржХрзНрж╖рзНржп рж╣рж▓рзЛ seek time ржХржорж╛ржирзЛ ржПржмржВ throughput ржмрж╛рзЬрж╛ржирзЛред

---

## ЁЯФ╣ 1я╕ПтГг FCFS (First Come First Serve)

**English:**  
Requests are serviced in arrival order. Simple, fair, but may cause high seek time.

**ржмрж╛ржВрж▓рж╛:**  
Requests ржпрзЗржнрж╛ржмрзЗ ржЖрж╕рзЗ, рж╕рзЗржнрж╛ржмрзЗржЗ рж╕рж╛рж░рзНржнрж┐рж╕ ржХрж░рж╛ рж╣рзЯред рж╕рж╣ржЬ ржУ ржирзНржпрж╛ржпрзНржп, ржХрж┐ржирзНрждрзБ seek time ржмрзЗрж╢рж┐ рж╣рждрзЗ ржкрж╛рж░рзЗред

**Example:**  
- Disk Queue: 98, 183, 37, 122, 14  
- Initial Head: 53  
- Sequence: 53 тЖТ 98 тЖТ 183 тЖТ 37 тЖТ 122 тЖТ 14

---

## ЁЯФ╣ 2я╕ПтГг SSTF (Shortest Seek Time First)

**English:**  
Service the request closest to the current head position. Reduces average seek time, but may cause starvation.

**ржмрж╛ржВрж▓рж╛:**  
Current head ржерзЗржХрзЗ рж╕ржмржЪрзЗрзЯрзЗ ржХрж╛ржЫрзЗрж░ request ржкрзНрж░ржержорзЗ рж╕рж╛рж░рзНржнрж┐рж╕ ржХрж░рж╛ рж╣рзЯред Average seek time ржХржорзЗ, ржХрж┐ржирзНрждрзБ starvation рж╣рждрзЗ ржкрж╛рж░рзЗред

**Example:**  
- Head: 53  
- Queue: 98, 183, 37, 122, 14  
- Sequence (closest first): 53 тЖТ 37 тЖТ 14 тЖТ 98 тЖТ 122 тЖТ 183

---

## ЁЯФ╣ 3я╕ПтГг SCAN (Elevator Algorithm)

**English:**  
Disk head moves in one direction, servicing requests until it reaches the end, then reverses direction. Fair, reduces starvation for far requests.

**ржмрж╛ржВрж▓рж╛:**  
Disk head ржПржХржжрж┐ржХрзЗ ржЪрж▓рзЗ, рж╕ржм requests рж╕рж╛рж░рзНржнрж┐рж╕ ржХрж░рзЗ рж╢рзЗрж╖рзЗ ржлрж┐рж░рзЗ ржЖрж╕рзЗред ржирзНржпрж╛ржпрзНржп ржПржмржВ ржжрзВрж░рзЗрж░ requests-ржПрж░ ржЬржирзНржп ржЙржкржХрж╛рж░рзАред

---

## ЁЯФ╣ 4я╕ПтГг C-SCAN (Circular SCAN)

**English:**  
Like SCAN, but after reaching the end, head jumps back to start without servicing in reverse. Provides uniform wait time.

**ржмрж╛ржВрж▓рж╛:**  
SCAN-ржПрж░ ржорждрзЛ, ржХрж┐ржирзНрждрзБ рж╢рзЗрж╖рзЗ head рж╢рзБрж░рзБрждрзЗ ржлрж┐рж░рзЗ ржпрж╛рзЯ, reverse servicing ржирзЗржЗред Wait time рж╕ржорж╛ржиржнрж╛ржмрзЗ ржмрж┐рждрж░ржг рж╣рзЯред

---

## ЁЯФ╣ 5я╕ПтГг LOOK / C-LOOK

**English:**  
Similar to SCAN/C-SCAN, but head reverses at last request, not at disk end. Reduces unnecessary movement.

**ржмрж╛ржВрж▓рж╛:**  
SCAN/C-SCAN-ржПрж░ ржорждрзЛ, ржХрж┐ржирзНрждрзБ head рж╢рзЗрж╖ request-ржП ржлрж┐рж░рзЗ ржпрж╛рзЯ, disk end-ржП ржирзЯред ржЕржкрзНрж░рзЯрзЛржЬржирзАрзЯ movement ржХржорзЗ ржпрж╛рзЯред

---

## ЁЯФ╣ Comparison Table (рждрзБрж▓ржирж╛)

| Algorithm | Strategy | Advantage | Disadvantage | Use Case |
|-----------|---------|-----------|--------------|----------|
| FCFS | Arrival order | Simple, fair | High seek time | Simple systems |
| SSTF | Shortest seek | Reduces seek time | Starvation possible | Moderate systems |
| SCAN | One direction, reverse at end | Fair, reduces starvation | Head movement may be long | OS, batch systems |
| C-SCAN | One direction, jump to start | Uniform wait time | Slightly longer seek | Time-sharing systems |
| LOOK / C-LOOK | Reverse at last request | Efficient, less movement | Slightly complex | Modern OS |

---

## ЁЯФС Key Points (ржорзВрж▓ ржмрж┐рж╖рзЯ)

- Disk Scheduling reduces average seek time & improves throughput  
- Choice depends on system load, fairness, and performance goals  
- SSTF тЙИ short-term efficiency, SCAN/C-SCAN тЙИ fairness, LOOK тЙИ optimal movement
---

# ЁЯза Cache (ржХрзНржпрж╛рж╢рзЗ)

---

## ЁЯзй Definition (рж╕ржВржЬрзНржЮрж╛)

### English:
A cache is a small, high-speed memory located close to the CPU that stores frequently accessed data or instructions.  
It helps the CPU access data faster than retrieving it from main memory (RAM).

### ржмрж╛ржВрж▓рж╛:
ржХрзНржпрж╛рж╢рзЗ рж╣рж▓рзЛ CPU-ржПрж░ ржХрж╛ржЫрзЗ ржерж╛ржХрж╛ ржЫрзЛржЯ, ржЙржЪрзНржЪ-ржЧрждрж┐рж░ ржорзЗржорзЛрж░рж┐, ржпрзЗржЦрж╛ржирзЗ рж╕рж░рзНржмрж╛ржзрж┐ржХ ржмрзНржпржмрж╣рзГржд ржбрзЗржЯрж╛ ржмрж╛ ржирж┐рж░рзНржжрзЗрж╢ рж╕ржВрж░ржХрзНрж╖рж┐ржд ржерж╛ржХрзЗред  
ржПржЯрж┐ CPU ржХрзЗ RAM ржерзЗржХрзЗ ржбрзЗржЯрж╛ ржЖржирж╛рж░ ржЪрзЗржпрж╝рзЗ ржжрзНрж░рзБржд рждржерзНржп ржжрж┐рждрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рзЗред

---

## ЁЯФ╣ Why Cache is Needed (ржХрзЗржи ржжрж░ржХрж╛рж░)

- **English:** CPU faster than RAM; frequent access data тЖТ reduce memory access time; improves system performance  
- **ржмрж╛ржВрж▓рж╛:** CPU рж╣рж▓рзЛ RAM-ржПрж░ рждрзБрж▓ржирж╛рзЯ ржжрзНрж░рзБржд; ржкрзНрж░рж╛ржпрж╝ржЗ ржмрзНржпржмрж╣рзГржд ржбрзЗржЯрж╛ тЖТ ржорзЗржорзЛрж░рж┐ access time ржХржорж╛рзЯ; System performance ржмрзГржжрзНржзрж┐ ржкрж╛ржпрж╝

---

## ЁЯФ╣ Types of Cache (ржХрзНржпрж╛рж╢рзЗрж░ ржзрж░ржи)

| Type | English Description | ржмрж╛ржВрж▓рж╛ |
|------|-------------------|-------|
| L1 Cache | Built-in CPU cache, fastest, small size (16-128 KB) | CPU-рждрзЗ ржЕржирзНрждрж░рзНржирж┐рж░рзНржорж┐ржд, ржжрзНрж░рзБрждрждржо, ржЫрзЛржЯ |
| L2 Cache | Larger, slightly slower, secondary cache | ржмржбрж╝, ржПржХржЯрзБ ржзрзАрж░, secondary cache |
| L3 Cache | Shared among cores, larger but slower than L2 | Core-ржПрж░ ржоржзрзНржпрзЗ ржнрж╛ржЧ ржХрж░рж╛, L2-ржПрж░ ржЪрзЗржпрж╝рзЗ ржмржбрж╝ ржХрж┐ржирзНрждрзБ ржзрзАрж░ |

---

## ЁЯФ╣ Cache Mapping Techniques

| Technique | English Description | ржмрж╛ржВрж▓рж╛ |
|-----------|------------------|-------|
| Direct Mapped | Each block of main memory maps to exactly one cache line. Simple, but may cause conflicts. | ржПржХ block ржарж┐ржХ ржПржХржЗ cache line ржП ржпрж╛ржмрзЗ |
| Fully Associative | Any block can go to any cache line. Flexible, but complex hardware. | ржХрзЛржирзЛ block ржХрзЛржирзЛ line ржП ржпрзЗрждрзЗ ржкрж╛рж░рзЗ |
| Set-Associative | Combination of direct & fully associative. Memory divided into sets; block maps to a set of lines. | set-ржПрж░ ржоржзрзНржпрзЗ block-map |

---

## ЁЯФ╣ Cache Write Policies

| Policy | Description | Advantage | Disadvantage |
|--------|------------|-----------|--------------|
| Write-Through | Write to cache & main memory simultaneously | Data always consistent | Slower writes |
| Write-Back | Write only to cache, update memory later | Faster | Complexity, possible data loss on crash |

---

## ЁЯФ╣ Cache Hit & Miss

- **Cache Hit:** Requested data found in cache тЖТ fast access  
- **Cache Miss:** Requested data not in cache тЖТ fetch from main memory  

**Performance Metric:**  
`CPU Time = (Hit Ratio ├Ч Cache Access Time) + (Miss Ratio ├Ч Memory Access Time)`

---

## ЁЯФС Key Points (ржорзВрж▓ ржмрж┐рж╖рзЯ)

- Cache is high-speed memory near CPU  
- Reduces average memory access time  
- Types: L1, L2, L3  
- Mapping: Direct, Fully, Set-Associative  
- Write Policy: Write-Through / Write-Back  
- Hit/Miss ratio determines cache efficiency

---
